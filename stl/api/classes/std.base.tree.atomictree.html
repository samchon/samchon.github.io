<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>AtomicTree | </title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../assets/css/main.css">
	<script src="../assets/js/modernizr.js"></script>
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="../assets/js/search.js" data-base="..">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="../index.html" class="title"></a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="../globals.html">Globals</a>
				</li>
				<li>
					<a href="../modules/std.html">std</a>
				</li>
				<li>
					<a href="../modules/std.base.html">base</a>
				</li>
				<li>
					<a href="../modules/std.base.tree.html">tree</a>
				</li>
				<li>
					<a href="std.base.tree.atomictree.html">AtomicTree</a>
				</li>
			</ul>
			<h1>Class AtomicTree&lt;T&gt;</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<section class="tsd-panel tsd-type-parameters">
				<h3>Type parameters</h3>
				<ul class="tsd-type-parameters">
					<li>
						<h4>T</h4>
					</li>
				</ul>
			</section>
			<section class="tsd-panel tsd-hierarchy">
				<h3>Hierarchy</h3>
				<ul class="tsd-hierarchy">
					<li>
						<a href="std.base.tree.xtree.html" class="tsd-signature-type">XTree</a><span class="tsd-signature-symbol">&lt;</span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span>
						<ul class="tsd-hierarchy">
							<li>
								<span class="target">AtomicTree</span>
							</li>
						</ul>
					</li>
				</ul>
			</section>
			<section class="tsd-panel-group tsd-index-group">
				<h2>Index</h2>
				<section class="tsd-panel tsd-index-panel">
					<div class="tsd-index-content">
						<section class="tsd-index-section ">
							<h3>Constructors</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-overwrite"><a href="std.base.tree.atomictree.html#constructor" class="tsd-kind-icon">constructor</a></li>
							</ul>
						</section>
						<section class="tsd-index-section tsd-is-inherited tsd-is-private-protected">
							<h3>Properties</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited tsd-is-protected"><a href="std.base.tree.atomictree.html#root" class="tsd-kind-icon">root</a></li>
							</ul>
						</section>
						<section class="tsd-index-section ">
							<h3>Methods</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="std.base.tree.atomictree.html#erase" class="tsd-kind-icon">erase</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-overwrite"><a href="std.base.tree.atomictree.html#find" class="tsd-kind-icon">find</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.atomictree.html#findbyval" class="tsd-kind-icon">find<wbr>ByVal</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="std.base.tree.atomictree.html#insert" class="tsd-kind-icon">insert</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-overwrite"><a href="std.base.tree.atomictree.html#isequals" class="tsd-kind-icon">is<wbr>Equals</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-overwrite"><a href="std.base.tree.atomictree.html#isless" class="tsd-kind-icon">is<wbr>Less</a></li>
							</ul>
						</section>
					</div>
				</section>
			</section>
			<section class="tsd-panel-group tsd-member-group ">
				<h2>Constructors</h2>
				<section class="tsd-panel tsd-member tsd-kind-constructor tsd-parent-kind-class tsd-is-overwrite">
					<a name="constructor" class="tsd-anchor"></a>
					<h3>constructor</h3>
					<ul class="tsd-signatures tsd-kind-constructor tsd-parent-kind-class tsd-is-overwrite">
						<li class="tsd-signature tsd-kind-icon">new <wbr>Atomic<wbr>Tree<span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="std.base.tree.atomictree.html" class="tsd-signature-type">AtomicTree</a></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<p>Overwrites <a href="std.base.tree.xtree.html">XTree</a>.<a href="std.base.tree.xtree.html#constructor">constructor</a></p>
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/AtomicTree.ts#L7">base/tree/AtomicTree.ts:7</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p>Default Constructor.</p>
								</div>
							</div>
							<h4 class="tsd-returns-title">Returns <a href="std.base.tree.atomictree.html" class="tsd-signature-type">AtomicTree</a></h4>
						</li>
					</ul>
				</section>
			</section>
			<section class="tsd-panel-group tsd-member-group tsd-is-inherited tsd-is-private-protected">
				<h2>Properties</h2>
				<section class="tsd-panel tsd-member tsd-kind-property tsd-parent-kind-class tsd-is-inherited tsd-is-protected">
					<a name="root" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagProtected">Protected</span> root</h3>
					<div class="tsd-signature tsd-kind-icon">root<span class="tsd-signature-symbol">:</span> <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></div>
					<aside class="tsd-sources">
						<p>Inherited from <a href="std.base.tree.xtree.html">XTree</a>.<a href="std.base.tree.xtree.html#root">root</a></p>
						<ul>
							<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L67">base/tree/XTree.ts:67</a></li>
						</ul>
					</aside>
				</section>
			</section>
			<section class="tsd-panel-group tsd-member-group ">
				<h2>Methods</h2>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited">
					<a name="erase" class="tsd-anchor"></a>
					<h3>erase</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited">
						<li class="tsd-signature tsd-kind-icon">erase<span class="tsd-signature-symbol">(</span>val<span class="tsd-signature-symbol">: </span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<p>Inherited from <a href="std.base.tree.xtree.html">XTree</a>.<a href="std.base.tree.xtree.html#erase">erase</a></p>
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L453">base/tree/XTree.ts:453</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> Erase an element with its node. </p>
								</div>
								<p> In a regular binary search tree when deleting a node with two non-leaf children, we find either the
									maximum element in its left subtree (which is the in-order predecessor) or the minimum element in its
									right subtree (which is the in-order successor) and move its value into the node being deleted (as shown
									here). We then delete the node we copied the value from, which must have fewer than two non-leaf children.
									(Non-leaf children, rather than all children, are specified here because unlike normal binary search
									trees, red–black trees can have leaf nodes anywhere, so that all nodes are either internal nodes with
									two children or leaf nodes with, by definition, zero children. In effect, internal nodes having two leaf
									children in a red–black tree are like the leaf nodes in a regular binary search tree.) Because merely
									copying a value does not violate any red–black properties, this reduces to the problem of deleting a node
									with at most one non-leaf child. Once we have solved that problem, the solution applies equally to the
									case where the node we originally want to delete has at most one non-leaf child as to the case just
								considered where it has two non-leaf children. </p>
								<p> Therefore, for the remainder of this discussion we address the deletion of a node with at most one
									non-leaf child. We use the label M to denote the node to be deleted; C will denote a selected child of M,
									which we will also call &quot;its child&quot;. If M does have a non-leaf child, call that its child, C; otherwise,
								choose either leaf as its child, C. </p>
								<p> If M is a red node, we simply replace it with its child C, which must be black by property 4.
									(This can only occur when M has two leaf children, because if the red node M had a black non-leaf child
									on one side but just a leaf child on the other side, then the count of black nodes on both sides would
									be different, thus the tree would violate property 5.) All paths through the deleted node will simply
									pass through one fewer red node, and both the deleted node&#39;s parent and child must be black,
									so property 3 (all leaves are black) and property 4 (both children of every red node are black) still
								hold. </p>
								<p> Another simple case is when M is black and C is red. Simply removing a black node could break
									Properties 4 (“Both children of every red node are black”) and 5 (“All paths from any given node to its
									leaf nodes contain the same number of black nodes”), but if we repaint C black, both of these properties
								are preserved. </p>
								<p> The complex case is when both M and C are black. (This can only occur when deleting a black node
									which has two leaf children, because if the black node M had a black non-leaf child on one side but just
									a leaf child on the other side, then the count of black nodes on both sides would be different, thus the
									tree would have been an invalid red–black tree by violation of property 5.) We begin by replacing M with
									its child C. We will relabel this child C (in its new position) N, and its sibling (its new parent&#39;s
									other child) S. (S was previously the sibling of M.) In the diagrams below, we will also use P for N&#39;s
									new parent (M&#39;s old parent), SL for S&#39;s left child, and SR for S&#39;s right child (S cannot be a leaf
									because if M and C were black, then P&#39;s one subtree which included M counted two black-height and thus
									P&#39;s other subtree which includes S must also count two black-height, which cannot be the case if S is a
								leaf node). </p>
								<p><h4> Notes </h4></p>
								<ol>
									<li> The label N will be used to denote the current node (colored black). In the diagrams N carries a
										blue contour. At the beginning, this is the replacement node and a leaf, but the entire procedure
										may also be applied recursively to other nodes (see case 3). In between some cases, the roles and
										labels of the nodes are exchanged, but in each case, every label continues to represent the same
									node it represented at the beginning of the case. </li>
									<li> If a node in the right (target) half of a diagram carries a blue contour it will become the current
										node in the next iteration and there the other nodes will be newly assigned relative to it. Any
										color shown in the diagram is either assumed in its case or implied by those assumptions.
										White represents an arbitrary color (either red or black), but the same in both halves of the
									diagram. </li>
									<li> A numbered triangle represents a subtree of unspecified depth. A black circle atop a triangle means
									that black-height of subtree is greater by one compared to subtree without this circle. </li>
								</ol>
								<p> If both N and its original parent are black, then deleting this original parent causes paths which
									proceed through N to have one fewer black node than paths that do not. As this violates property 5
									(all paths from any given node to its leaf nodes contain the same number of black nodes), the tree must
								be rebalanced. There are several cases to consider: </p>
								<ol>
									<li> N is the new root. </li>
									<li> S is red. </li>
									<li> P, S, and S&#39;s children are black. </li>
									<li> S and S&#39;s children are black, but P is red. </li>
									<li> S is black, S&#39;s left child is red, S&#39;s right child is black, and N is the left child of its parent. </li>
									<li> S is black, S&#39;s right child is red, and N is the left child of its parent P. </li>
								</ol>
								<p> Again, the function calls all use tail recursion, so the algorithm is in-place. </p>
								<p> In the algorithm above, all cases are chained in order, except in delete case 3 where it can recurse
									to case 1 back to the parent node: this is the only case where an iterative implementation will
									effectively loop. No more than h loops back to case 1 will occur (where h is the height of the tree).
									And because the probability for escalation decreases exponentially with each iteration the average
								removal cost is constant. </p>
								<p> Additionally, no tail recursion ever occurs on a child node, so the tail recursion loop can only
									move from a child back to its successive ancestors. If a rotation occurs in case 2 (which is the only
									possibility of rotation within the loop of cases 1–3), then the parent of the node N becomes red after
									the rotation and we will exit the loop. Therefore, at most one rotation will occur within this loop.
									Since no more than two additional rotations will occur after exiting the loop, at most three rotations
								occur in total. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>val: <a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>An element to erase.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-overwrite">
					<a name="find" class="tsd-anchor"></a>
					<h3>find</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-overwrite">
						<li class="tsd-signature tsd-kind-icon">find<span class="tsd-signature-symbol">(</span>val<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></li>
						<li class="tsd-signature tsd-kind-icon">find<span class="tsd-signature-symbol">(</span>it<span class="tsd-signature-symbol">: </span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<p>Overwrites <a href="std.base.tree.xtree.html">XTree</a>.<a href="std.base.tree.xtree.html#find">find</a></p>
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/AtomicTree.ts#L19">base/tree/AtomicTree.ts:19</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>val: <span class="tsd-signature-type">T</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h4>
						</li>
						<li class="tsd-description">
							<aside class="tsd-sources">
								<p>Overwrites <a href="std.base.tree.xtree.html">XTree</a>.<a href="std.base.tree.xtree.html#find">find</a></p>
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/AtomicTree.ts#L20">base/tree/AtomicTree.ts:20</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>it: <a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="findbyval" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> find<wbr>ByVal</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">find<wbr>ByVal<span class="tsd-signature-symbol">(</span>val<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/AtomicTree.ts#L30">base/tree/AtomicTree.ts:30</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>val: <span class="tsd-signature-type">T</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited">
					<a name="insert" class="tsd-anchor"></a>
					<h3>insert</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited">
						<li class="tsd-signature tsd-kind-icon">insert<span class="tsd-signature-symbol">(</span>val<span class="tsd-signature-symbol">: </span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<p>Inherited from <a href="std.base.tree.xtree.html">XTree</a>.<a href="std.base.tree.xtree.html#insert">insert</a></p>
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L203">base/tree/XTree.ts:203</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> Insert an element with a new node. </p>
								</div>
								<p> Insertion begins by adding the node as any binary search tree insertion does and by coloring it red.
									Whereas in the binary search tree, we always add a leaf, in the red–black tree, leaves contain no
									information, so instead we add a red interior node, with two black leaves, in place of an existing black
								leaf. </p>
								<p> What happens next depends on the color of other nearby nodes. The term uncle node will be used to
								refer to the sibling of a node&#39;s parent, as in human family trees. Note that: </p>
								<ul>
									<li> property 3 (all leaves are black) always holds. </li>
									<li> property 4 (both children of every red node are black) is threatened only by adding a red node,
									repainting a black node red, or a rotation. </li>
									<li> property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes)
										is threatened only by adding a black node, repainting a red node black (or vice versa), or a
									rotation. </li>
								</ul>
								<p><h4> Notes </h4></p>
								<ol>
									<li> The label N will be used to denote the current node (colored red). In the diagrams N carries a
										blue contour. At the beginning, this is the new node being inserted, but the entire procedure may
										also be applied recursively to other nodes (see case 3). P will denote N&#39;s parent node,
										G will denote N&#39;s grandparent, and U will denote N&#39;s uncle. In between some cases, the roles and
										labels of the nodes are exchanged, but in each case, every label continues to represent the same
									node it represented at the beginning of the case. </li>
									<li> If a node in the right (target) half of a diagram carries a blue contour it will become the current
										node in the next iteration and there the other nodes will be newly assigned relative to it. Any
									color shown in the diagram is either assumed in its case or implied by those assumptions. </li>
									<li> A numbered triangle represents a subtree of unspecified depth. A black circle atop a triangle means
									that black-height of subtree is greater by one compared to subtree without this circle. </li>
								</ol>
								<p> There are several cases of red–black tree insertion to handle: </p>
								<ul>
									<li> N is the root node, i.e., first node of red–black tree. </li>
									<li> N&#39;s parent (P) is black. </li>
									<li> N&#39;s parent (P) and uncle (U) are red. </li>
									<li> N is added to right of left child of grandparent, or N is added to left of right child of
									grandparent (P is red and U is black). </li>
									<li> N is added to left of left child of grandparent, or N is added to right of right child of
									grandparent (P is red and U is black). </li>
								</ul>
								<p><h4> Note </h4></p>
								<p> Note that inserting is actually in-place, since all the calls above use tail recursion. </p>
								<p> In the algorithm above, all cases are chained in order, except in insert case 3 where it can recurse
									to case 1 back to the grandparent node: this is the only case where an iterative implementation will
									effectively loop. Because the problem of repair is escalated to the next higher level but one, it takes
									maximally h⁄2 iterations to repair the tree (where h is the height of the tree). Because the probability
								for escalation decreases exponentially with each iteration the average insertion cost is constant. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>val: <a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>An element to insert.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-overwrite">
					<a name="isequals" class="tsd-anchor"></a>
					<h3>is<wbr>Equals</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-overwrite">
						<li class="tsd-signature tsd-kind-icon">is<wbr>Equals<span class="tsd-signature-symbol">(</span>left<span class="tsd-signature-symbol">: </span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span>, right<span class="tsd-signature-symbol">: </span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">boolean</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<p>Overwrites <a href="std.base.tree.xtree.html">XTree</a>.<a href="std.base.tree.xtree.html#isequals">isEquals</a></p>
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/AtomicTree.ts#L62">base/tree/AtomicTree.ts:62</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>left: <a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
								<li>
									<h5>right: <a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">boolean</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-overwrite">
					<a name="isless" class="tsd-anchor"></a>
					<h3>is<wbr>Less</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-overwrite">
						<li class="tsd-signature tsd-kind-icon">is<wbr>Less<span class="tsd-signature-symbol">(</span>left<span class="tsd-signature-symbol">: </span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span>, right<span class="tsd-signature-symbol">: </span><a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">boolean</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<p>Overwrites <a href="std.base.tree.xtree.html">XTree</a>.<a href="std.base.tree.xtree.html#isless">isLess</a></p>
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/AtomicTree.ts#L67">base/tree/AtomicTree.ts:67</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>left: <a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
								<li>
									<h5>right: <a href="std.setiterator.html" class="tsd-signature-type">SetIterator</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">boolean</span></h4>
						</li>
					</ul>
				</section>
			</section>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="../globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-module">
						<a href="../modules/std.html">std</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.base.html">std.base</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.base.container.html">std.base.container</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.base.hash.html">std.base.hash</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.base.system.html">std.base.system</a>
					</li>
					<li class="current tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.base.tree.html">std.base.tree</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.example.html">std.example</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.system.html">std.system</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
				<ul class="current">
					<li class="current tsd-kind-class tsd-parent-kind-module tsd-has-type-parameter">
						<a href="std.base.tree.atomictree.html" class="tsd-kind-icon">Atomic<wbr>Tree</a>
						<ul>
							<li class=" tsd-kind-constructor tsd-parent-kind-class tsd-is-overwrite">
								<a href="std.base.tree.atomictree.html#constructor" class="tsd-kind-icon">constructor</a>
							</li>
							<li class=" tsd-kind-property tsd-parent-kind-class tsd-is-inherited tsd-is-protected">
								<a href="std.base.tree.atomictree.html#root" class="tsd-kind-icon">root</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-inherited">
								<a href="std.base.tree.atomictree.html#erase" class="tsd-kind-icon">erase</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-overwrite">
								<a href="std.base.tree.atomictree.html#find" class="tsd-kind-icon">find</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.atomictree.html#findbyval" class="tsd-kind-icon">find<wbr>ByVal</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-inherited">
								<a href="std.base.tree.atomictree.html#insert" class="tsd-kind-icon">insert</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-overwrite">
								<a href="std.base.tree.atomictree.html#isequals" class="tsd-kind-icon">is<wbr>Equals</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-overwrite">
								<a href="std.base.tree.atomictree.html#isless" class="tsd-kind-icon">is<wbr>Less</a>
							</li>
						</ul>
					</li>
				</ul>
				<ul class="after-current">
					<li class=" tsd-kind-class tsd-parent-kind-module">
						<a href="std.base.tree.color.html" class="tsd-kind-icon">Color</a>
					</li>
					<li class=" tsd-kind-class tsd-parent-kind-module tsd-has-type-parameter">
						<a href="std.base.tree.pairtree.html" class="tsd-kind-icon">Pair<wbr>Tree</a>
					</li>
					<li class=" tsd-kind-class tsd-parent-kind-module tsd-has-type-parameter">
						<a href="std.base.tree.xtree.html" class="tsd-kind-icon">XTree</a>
					</li>
					<li class=" tsd-kind-class tsd-parent-kind-module tsd-has-type-parameter">
						<a href="std.base.tree.xtreenode.html" class="tsd-kind-icon">XTree<wbr>Node</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.io" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="../assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="../assets/js/search.js"><' + '/script>');</script>
</body>
</html>