<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>XTree | </title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../assets/css/main.css">
	<script src="../assets/js/modernizr.js"></script>
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="../assets/js/search.js" data-base="..">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="../index.html" class="title"></a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="../globals.html">Globals</a>
				</li>
				<li>
					<a href="../modules/std.html">std</a>
				</li>
				<li>
					<a href="../modules/std.base.html">base</a>
				</li>
				<li>
					<a href="../modules/std.base.tree.html">tree</a>
				</li>
				<li>
					<a href="std.base.tree.xtree.html">XTree</a>
				</li>
			</ul>
			<h1>Class XTree&lt;T&gt;</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<section class="tsd-panel tsd-comment">
				<div class="tsd-comment tsd-typography">
					<div class="lead">
						<p> Red-black Tree. </p>
					</div>
					<p> A red–black tree is a kind of self-balancing binary search tree. Each node of the binary tree has an
						extra bit, and that bit is often interpreted as the color (red or black) of the node. These color bits are
					used to ensure the tree remains approximately balanced during insertions and deletions. </p>
					<p> Balance is preserved by painting each node of the tree with one of two colors (typically called &#39;red&#39;
						and &#39;black&#39;) in a way that satisfies certain properties, which collectively constrain how unbalanced the
						tree can become in the worst case. When the tree is modified, the new tree is subsequently rearranged and
						repainted to restore the coloring properties. The properties are designed in such a way that this
					rearranging and recoloring can be performed efficiently. </p>
					<p> The balancing of the tree is not perfect but it is good enough to allow it to guarantee searching in
						O(log n) time, where n is the total number of elements in the tree. The insertion and deletion operations,
					along with the tree rearrangement and recoloring, are also performed in O(log n) time. </p>
					<p> Tracking the color of each node requires only 1 bit of information per node because there are only two
						colors. The tree does not contain any other data specific to its being a red–black tree so its memory
						footprint is almost identical to a classic (uncolored) binary search tree. In many cases the additional bit
					of information can be stored at no additional memory cost. </p>
					<p><h4> Properties </h4></p>
					<p> In addition to the requirements imposed on a binary search tree the following must be satisfied by a
					red–black tree: </p>
					<ol>
						<li> A node is either red or black. </li>
						<li> The root is black. This rule is sometimes omitted. Since the root can always be changed from red to
						black, but not necessarily vice versa, this rule has little effect on analysis. </li>
						<li> All leaves (NIL; <code>null</code>) are black. </li>
						<li> If a node is red, then both its children are black. </li>
						<li> Every path from a given node to any of its descendant NIL nodes contains the same number of black
							nodes. Some definitions: the number of black nodes from the root to a node is the node&#39;s black depth;
							the uniform number of black nodes in all paths from root to the leaves is called the black-height of
						the red–black tree. </li>
					</ol>
					<p> These constraints enforce a critical property of red–black trees: the path from the root to the
						farthest leaf is no more than twice as long as the path from the root to the nearest leaf. The result is
						that the tree is roughly height-balanced. Since operations such as inserting, deleting, and finding values
						require worst-case time proportional to the height of the tree, this theoretical upper bound on the height
					allows red–black trees to be efficient in the worst case, unlike ordinary binary search trees. </p>
					<p> To see why this is guaranteed, it suffices to consider the effect of properties 4 and 5 together. For a
						red–black tree T, let B be the number of black nodes in property 5. Let the shortest possible path from the
						root of T to any leaf consist of B black nodes. Longer possible paths may be constructed by inserting red
						nodes. However, property 4 makes it impossible to insert more than one consecutive red node. Therefore,
						ignoring any black NIL leaves, the longest possible path consists of 2<em>B nodes, alternating black and red
					(this is the worst case). Counting the black NIL leaves, the longest possible path consists of 2</em>B-1 nodes. </p>
					<p> The shortest possible path has all black nodes, and the longest possible path alternates between red
						and black nodes. Since all maximal paths have the same number of black nodes, by property 5, this shows
					that no path is more than twice as long as any other path. </p>
					<ul>
						<li> Reference: <a href="https://en.wikipedia.org/w/index.php?title=Red%E2%80%93black_tree&amp;redirect=no">https://en.wikipedia.org/w/index.php?title=Red%E2%80%93black_tree&amp;redirect=no</a> </li>
					</ul>
					<dl class="tsd-comment-tags">
						<dt>inventor</dt>
						<dd><p>Rudolf Bayer</p>
						</dd>
						<dt>author</dt>
						<dd><p>Migrated by Jeongho Nam</p>
						</dd>
					</dl>
				</div>
			</section>
			<section class="tsd-panel tsd-type-parameters">
				<h3>Type parameters</h3>
				<ul class="tsd-type-parameters">
					<li>
						<h4>T</h4>
					</li>
				</ul>
			</section>
			<section class="tsd-panel tsd-hierarchy">
				<h3>Hierarchy</h3>
				<ul class="tsd-hierarchy">
					<li>
						<span class="target">XTree</span>
						<ul class="tsd-hierarchy">
							<li>
								<a href="std.base.tree.atomictree.html" class="tsd-signature-type">AtomicTree</a>
							</li>
							<li>
								<a href="std.base.tree.pairtree.html" class="tsd-signature-type">PairTree</a>
							</li>
						</ul>
					</li>
				</ul>
			</section>
			<section class="tsd-panel-group tsd-index-group">
				<h2>Index</h2>
				<section class="tsd-panel tsd-index-panel">
					<div class="tsd-index-content">
						<section class="tsd-index-section ">
							<h3>Constructors</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-constructor tsd-parent-kind-class"><a href="std.base.tree.xtree.html#constructor" class="tsd-kind-icon">constructor</a></li>
							</ul>
						</section>
						<section class="tsd-index-section tsd-is-private-protected">
							<h3>Properties</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><a href="std.base.tree.xtree.html#root" class="tsd-kind-icon">root</a></li>
							</ul>
						</section>
						<section class="tsd-index-section ">
							<h3>Methods</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-method tsd-parent-kind-class"><a href="std.base.tree.xtree.html#erase" class="tsd-kind-icon">erase</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#erasecase1" class="tsd-kind-icon">erase<wbr>Case1</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#erasecase2" class="tsd-kind-icon">erase<wbr>Case2</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#erasecase3" class="tsd-kind-icon">erase<wbr>Case3</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#erasecase4" class="tsd-kind-icon">erase<wbr>Case4</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#erasecase5" class="tsd-kind-icon">erase<wbr>Case5</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#erasecase6" class="tsd-kind-icon">erase<wbr>Case6</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#fetchcolor" class="tsd-kind-icon">fetch<wbr>Color</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#fetchmaximum" class="tsd-kind-icon">fetch<wbr>Maximum</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class"><a href="std.base.tree.xtree.html#find" class="tsd-kind-icon">find</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class"><a href="std.base.tree.xtree.html#insert" class="tsd-kind-icon">insert</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#insertcase1" class="tsd-kind-icon">insert<wbr>Case1</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#insertcase2" class="tsd-kind-icon">insert<wbr>Case2</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#insertcase3" class="tsd-kind-icon">insert<wbr>Case3</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#insertcase4" class="tsd-kind-icon">insert<wbr>Case4</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#insertcase5" class="tsd-kind-icon">insert<wbr>Case5</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class"><a href="std.base.tree.xtree.html#isequals" class="tsd-kind-icon">is<wbr>Equals</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class"><a href="std.base.tree.xtree.html#isless" class="tsd-kind-icon">is<wbr>Less</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#replacenode" class="tsd-kind-icon">replace<wbr>Node</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#rotateleft" class="tsd-kind-icon">rotate<wbr>Left</a></li>
								<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><a href="std.base.tree.xtree.html#rotateright" class="tsd-kind-icon">rotate<wbr>Right</a></li>
							</ul>
						</section>
					</div>
				</section>
			</section>
			<section class="tsd-panel-group tsd-member-group ">
				<h2>Constructors</h2>
				<section class="tsd-panel tsd-member tsd-kind-constructor tsd-parent-kind-class">
					<a name="constructor" class="tsd-anchor"></a>
					<h3>constructor</h3>
					<ul class="tsd-signatures tsd-kind-constructor tsd-parent-kind-class">
						<li class="tsd-signature tsd-kind-icon">new XTree<span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtree.html" class="tsd-signature-type">XTree</a></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L67">base/tree/XTree.ts:67</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p>Default Constructor.</p>
								</div>
							</div>
							<h4 class="tsd-returns-title">Returns <a href="std.base.tree.xtree.html" class="tsd-signature-type">XTree</a></h4>
						</li>
					</ul>
				</section>
			</section>
			<section class="tsd-panel-group tsd-member-group tsd-is-private-protected">
				<h2>Properties</h2>
				<section class="tsd-panel tsd-member tsd-kind-property tsd-parent-kind-class tsd-is-protected">
					<a name="root" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagProtected">Protected</span> root</h3>
					<div class="tsd-signature tsd-kind-icon">root<span class="tsd-signature-symbol">:</span> <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></div>
					<aside class="tsd-sources">
						<ul>
							<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L67">base/tree/XTree.ts:67</a></li>
						</ul>
					</aside>
				</section>
			</section>
			<section class="tsd-panel-group tsd-member-group ">
				<h2>Methods</h2>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class">
					<a name="erase" class="tsd-anchor"></a>
					<h3>erase</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class">
						<li class="tsd-signature tsd-kind-icon">erase<span class="tsd-signature-symbol">(</span>val<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L453">base/tree/XTree.ts:453</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> Erase an element with its node. </p>
								</div>
								<p> In a regular binary search tree when deleting a node with two non-leaf children, we find either the
									maximum element in its left subtree (which is the in-order predecessor) or the minimum element in its
									right subtree (which is the in-order successor) and move its value into the node being deleted (as shown
									here). We then delete the node we copied the value from, which must have fewer than two non-leaf children.
									(Non-leaf children, rather than all children, are specified here because unlike normal binary search
									trees, red–black trees can have leaf nodes anywhere, so that all nodes are either internal nodes with
									two children or leaf nodes with, by definition, zero children. In effect, internal nodes having two leaf
									children in a red–black tree are like the leaf nodes in a regular binary search tree.) Because merely
									copying a value does not violate any red–black properties, this reduces to the problem of deleting a node
									with at most one non-leaf child. Once we have solved that problem, the solution applies equally to the
									case where the node we originally want to delete has at most one non-leaf child as to the case just
								considered where it has two non-leaf children. </p>
								<p> Therefore, for the remainder of this discussion we address the deletion of a node with at most one
									non-leaf child. We use the label M to denote the node to be deleted; C will denote a selected child of M,
									which we will also call &quot;its child&quot;. If M does have a non-leaf child, call that its child, C; otherwise,
								choose either leaf as its child, C. </p>
								<p> If M is a red node, we simply replace it with its child C, which must be black by property 4.
									(This can only occur when M has two leaf children, because if the red node M had a black non-leaf child
									on one side but just a leaf child on the other side, then the count of black nodes on both sides would
									be different, thus the tree would violate property 5.) All paths through the deleted node will simply
									pass through one fewer red node, and both the deleted node&#39;s parent and child must be black,
									so property 3 (all leaves are black) and property 4 (both children of every red node are black) still
								hold. </p>
								<p> Another simple case is when M is black and C is red. Simply removing a black node could break
									Properties 4 (“Both children of every red node are black”) and 5 (“All paths from any given node to its
									leaf nodes contain the same number of black nodes”), but if we repaint C black, both of these properties
								are preserved. </p>
								<p> The complex case is when both M and C are black. (This can only occur when deleting a black node
									which has two leaf children, because if the black node M had a black non-leaf child on one side but just
									a leaf child on the other side, then the count of black nodes on both sides would be different, thus the
									tree would have been an invalid red–black tree by violation of property 5.) We begin by replacing M with
									its child C. We will relabel this child C (in its new position) N, and its sibling (its new parent&#39;s
									other child) S. (S was previously the sibling of M.) In the diagrams below, we will also use P for N&#39;s
									new parent (M&#39;s old parent), SL for S&#39;s left child, and SR for S&#39;s right child (S cannot be a leaf
									because if M and C were black, then P&#39;s one subtree which included M counted two black-height and thus
									P&#39;s other subtree which includes S must also count two black-height, which cannot be the case if S is a
								leaf node). </p>
								<p><h4> Notes </h4></p>
								<ol>
									<li> The label N will be used to denote the current node (colored black). In the diagrams N carries a
										blue contour. At the beginning, this is the replacement node and a leaf, but the entire procedure
										may also be applied recursively to other nodes (see case 3). In between some cases, the roles and
										labels of the nodes are exchanged, but in each case, every label continues to represent the same
									node it represented at the beginning of the case. </li>
									<li> If a node in the right (target) half of a diagram carries a blue contour it will become the current
										node in the next iteration and there the other nodes will be newly assigned relative to it. Any
										color shown in the diagram is either assumed in its case or implied by those assumptions.
										White represents an arbitrary color (either red or black), but the same in both halves of the
									diagram. </li>
									<li> A numbered triangle represents a subtree of unspecified depth. A black circle atop a triangle means
									that black-height of subtree is greater by one compared to subtree without this circle. </li>
								</ol>
								<p> If both N and its original parent are black, then deleting this original parent causes paths which
									proceed through N to have one fewer black node than paths that do not. As this violates property 5
									(all paths from any given node to its leaf nodes contain the same number of black nodes), the tree must
								be rebalanced. There are several cases to consider: </p>
								<ol>
									<li> N is the new root. </li>
									<li> S is red. </li>
									<li> P, S, and S&#39;s children are black. </li>
									<li> S and S&#39;s children are black, but P is red. </li>
									<li> S is black, S&#39;s left child is red, S&#39;s right child is black, and N is the left child of its parent. </li>
									<li> S is black, S&#39;s right child is red, and N is the left child of its parent P. </li>
								</ol>
								<p> Again, the function calls all use tail recursion, so the algorithm is in-place. </p>
								<p> In the algorithm above, all cases are chained in order, except in delete case 3 where it can recurse
									to case 1 back to the parent node: this is the only case where an iterative implementation will
									effectively loop. No more than h loops back to case 1 will occur (where h is the height of the tree).
									And because the probability for escalation decreases exponentially with each iteration the average
								removal cost is constant. </p>
								<p> Additionally, no tail recursion ever occurs on a child node, so the tail recursion loop can only
									move from a child back to its successive ancestors. If a rotation occurs in case 2 (which is the only
									possibility of rotation within the loop of cases 1–3), then the parent of the node N becomes red after
									the rotation and we will exit the loop. Therefore, at most one rotation will occur within this loop.
									Since no more than two additional rotations will occur after exiting the loop, at most three rotations
								occur in total. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>val: <span class="tsd-signature-type">T</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>An element to erase.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="erasecase1" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> erase<wbr>Case1</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">erase<wbr>Case1<span class="tsd-signature-symbol">(</span>N<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L491">base/tree/XTree.ts:491</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> N is the new root. </p>
								</div>
								<p> In this case, we are done. We removed one black node from every path, and the new root is black,
								so the properties are preserved. </p>
								<p><h4> Note </h4></p>
								<p> In cases 2, 5, and 6, we assume N is the left child of its parent P. If it is the right child,
									left and right should be reversed throughout these three cases. Again, the code examples take both cases
								into account. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>N: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be erased or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="erasecase2" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> erase<wbr>Case2</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">erase<wbr>Case2<span class="tsd-signature-symbol">(</span>N<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L512">base/tree/XTree.ts:512</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> S is red. </p>
								</div>
								<p> In this case we reverse the colors of P and S, and then rotate left at P,
								turning S into N&#39;s grandparent. </p>
								<p> Note that P has to be black as it had a red child. The resulting subtree has a path short one black
									node so we are not done. Now N has a black sibling and a red parent, so we can proceed to step 4, 5, or 6.
									(Its new sibling is black because it was once the child of the red S.) In later cases, we will re-label
								N&#39;s new sibling as S. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>N: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be erased or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="erasecase3" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> erase<wbr>Case3</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">erase<wbr>Case3<span class="tsd-signature-symbol">(</span>node<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L541">base/tree/XTree.ts:541</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> P, S, and S&#39;s children are black. </p>
								</div>
								<p> In this case, we simply repaint S red. The result is that all paths passing through S, which are
									precisely those paths not passing through N, have one less black node. Because deleting N&#39;s original
								parent made all paths passing through N have one less black node, this evens things up. </p>
								<p>However, all paths through P now have one fewer black node than paths that do not pass through P, so
									property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes) is
								still violated. To correct this, we perform the rebalancing procedure on P, starting at case 1. </p></p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>node: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be erased or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="erasecase4" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> erase<wbr>Case4</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">erase<wbr>Case4<span class="tsd-signature-symbol">(</span>N<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L564">base/tree/XTree.ts:564</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> S and S&#39;s children are black, but P is red. In this case, we simply exchange the colors of S and P. </p>
								</div>
								<p> This does not affect the number of black nodes on paths going through S, but it does add one to the
								number of black nodes on paths going through N, making up for the deleted black node on those paths. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>N: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be erased or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="erasecase5" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> erase<wbr>Case5</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">erase<wbr>Case5<span class="tsd-signature-symbol">(</span>N<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L589">base/tree/XTree.ts:589</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> S is black, S&#39;s left child is red, S&#39;s right child is black, and N is the left child of its parent. </p>
								</div>
								<p> In this case we rotate right at S, so that S&#39;s left child becomes S&#39;s parent and N&#39;s new sibling.
									We then exchange the colors of S and its new parent. All paths still have the same number of black nodes,
									but now N has a black sibling whose right child is red, so we fall into case 6. Neither N nor its parent
								are affected by this transformation. (Again, for case 6, we relabel N&#39;s new sibling as S.) </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>N: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be erased or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="erasecase6" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> erase<wbr>Case6</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">erase<wbr>Case6<span class="tsd-signature-symbol">(</span>N<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L642">base/tree/XTree.ts:642</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> S is black, S&#39;s right child is red, and N is the left child of its parent P. </p>
								</div>
								<p> In this case we rotate left at P, so that S becomes the parent of P and S&#39;s right child. We then
									exchange the colors of P and S, and make S&#39;s right child black. The subtree still has the same color at
									its root, so Properties 4 (Both children of every red node are black) and 5 (All paths from any given
									node to its leaf nodes contain the same number of black nodes) are not violated. However, N now has one
									additional black ancestor: either P has become black, or it was black and S was added as a black
								grandparent. Thus, the paths passing through N pass through one additional black node. </p>
								<p> Meanwhile, if a path does not go through N, then there are two possibilities: </p>
								<ol>
									<li> It goes through N&#39;s new sibling SL, a node with arbitrary color and the root of the subtree
										labeled 3 (s. diagram). Then, it must go through S and P, both formerly and currently, as they
									have only exchanged colors and places. Thus the path contains the same number of black nodes. </li>
									<li> It goes through N&#39;s new uncle, S&#39;s right child. Then, it formerly went through S, S&#39;s parent,
										and S&#39;s right child SR (which was red), but now only goes through S, which has assumed the color
										of its former parent, and S&#39;s right child, which has changed from red to black (assuming S&#39;s
									color: black). The net effect is that this path goes through the same number of black nodes. </li>
									<p> Either way, the number of black nodes on these paths does not change. Thus, we have restored
										Properties 4 (Both children of every red node are black) and 5 (All paths from any given node to its
										leaf nodes contain the same number of black nodes). The white node in the diagram can be either red or
									black, but must refer to the same color both before and after the transformation. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>N: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be erased or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="fetchcolor" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> fetch<wbr>Color</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">fetch<wbr>Color<span class="tsd-signature-symbol">(</span>node<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">boolean</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L706">base/tree/XTree.ts:706</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>node: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">boolean</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="fetchmaximum" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> fetch<wbr>Maximum</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">fetch<wbr>Maximum<span class="tsd-signature-symbol">(</span>node<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L122">base/tree/XTree.ts:122</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>node: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class">
					<a name="find" class="tsd-anchor"></a>
					<h3>find</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class">
						<li class="tsd-signature tsd-kind-icon">find<span class="tsd-signature-symbol">(</span>val<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L94">base/tree/XTree.ts:94</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>val: <span class="tsd-signature-type">T</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class">
					<a name="insert" class="tsd-anchor"></a>
					<h3>insert</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class">
						<li class="tsd-signature tsd-kind-icon">insert<span class="tsd-signature-symbol">(</span>val<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L203">base/tree/XTree.ts:203</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> Insert an element with a new node. </p>
								</div>
								<p> Insertion begins by adding the node as any binary search tree insertion does and by coloring it red.
									Whereas in the binary search tree, we always add a leaf, in the red–black tree, leaves contain no
									information, so instead we add a red interior node, with two black leaves, in place of an existing black
								leaf. </p>
								<p> What happens next depends on the color of other nearby nodes. The term uncle node will be used to
								refer to the sibling of a node&#39;s parent, as in human family trees. Note that: </p>
								<ul>
									<li> property 3 (all leaves are black) always holds. </li>
									<li> property 4 (both children of every red node are black) is threatened only by adding a red node,
									repainting a black node red, or a rotation. </li>
									<li> property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes)
										is threatened only by adding a black node, repainting a red node black (or vice versa), or a
									rotation. </li>
								</ul>
								<p><h4> Notes </h4></p>
								<ol>
									<li> The label N will be used to denote the current node (colored red). In the diagrams N carries a
										blue contour. At the beginning, this is the new node being inserted, but the entire procedure may
										also be applied recursively to other nodes (see case 3). P will denote N&#39;s parent node,
										G will denote N&#39;s grandparent, and U will denote N&#39;s uncle. In between some cases, the roles and
										labels of the nodes are exchanged, but in each case, every label continues to represent the same
									node it represented at the beginning of the case. </li>
									<li> If a node in the right (target) half of a diagram carries a blue contour it will become the current
										node in the next iteration and there the other nodes will be newly assigned relative to it. Any
									color shown in the diagram is either assumed in its case or implied by those assumptions. </li>
									<li> A numbered triangle represents a subtree of unspecified depth. A black circle atop a triangle means
									that black-height of subtree is greater by one compared to subtree without this circle. </li>
								</ol>
								<p> There are several cases of red–black tree insertion to handle: </p>
								<ul>
									<li> N is the root node, i.e., first node of red–black tree. </li>
									<li> N&#39;s parent (P) is black. </li>
									<li> N&#39;s parent (P) and uncle (U) are red. </li>
									<li> N is added to right of left child of grandparent, or N is added to left of right child of
									grandparent (P is red and U is black). </li>
									<li> N is added to left of left child of grandparent, or N is added to right of right child of
									grandparent (P is red and U is black). </li>
								</ul>
								<p><h4> Note </h4></p>
								<p> Note that inserting is actually in-place, since all the calls above use tail recursion. </p>
								<p> In the algorithm above, all cases are chained in order, except in insert case 3 where it can recurse
									to case 1 back to the grandparent node: this is the only case where an iterative implementation will
									effectively loop. Because the problem of repair is escalated to the next higher level but one, it takes
									maximally h⁄2 iterations to repair the tree (where h is the height of the tree). Because the probability
								for escalation decreases exponentially with each iteration the average insertion cost is constant. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>val: <span class="tsd-signature-type">T</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>An element to insert.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="insertcase1" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> insert<wbr>Case1</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">insert<wbr>Case1<span class="tsd-signature-symbol">(</span>N<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L233">base/tree/XTree.ts:233</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> <i><b>N</b></i> is the root node, i.e., first node of red–black tree. </p>
								</div>
								<p> The current node <i><b>N</b></i> is at the <a href="std.base.tree.xtree.html#root">root</a> of the tree. In this case, it is repainted
									black to satisfy property 2 (the root is black). Since this adds one black node to every path at once,
									property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes)
								is not violated. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>N: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be inserted or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="insertcase2" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> insert<wbr>Case2</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">insert<wbr>Case2<span class="tsd-signature-symbol">(</span>N<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L253">base/tree/XTree.ts:253</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> <i><b>N</b></i>&#39;s parent (<b>P</b>) is black. </p>
								</div>
								<p> The current node&#39;s parent <b>P</b> is black, so property 4 (both children of every red node are black)
									is not invalidated. In this case, the tree is still valid. Property 5 (all paths from any given node to
									its leaf nodes contain the same number of black nodes) is not threatened, because the current node
									<i><b>N</b></i> has two black leaf children, but because <i><b>N</b></i> is red, the paths through each
									of its children have the same number of black nodes as the path through the leaf it replaced, which was
								black, and so this property remains satisfied. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>N: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be inserted or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="insertcase3" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> insert<wbr>Case3</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">insert<wbr>Case3<span class="tsd-signature-symbol">(</span>N<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L280">base/tree/XTree.ts:280</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> <i><b>N</b></i>&#39;s parent (<b>P</b>) and uncle (<i>U</i>) are red. </p>
								</div>
								<p> If both the parent <b>P</b> and the uncle <b>U</b> are <font color='red'>red</font>, then both of
									them can be repainted <font color='darkBlue'>black</font> and the grandparent <b>G</b> becomes
									<font color='red'>red</font> (to maintain property 5 (all paths from any given node to its leaf nodes
									contain the same number of <font color='darkBlue'>black</font> nodes)). Now, the current
									<font color='red'>red</font> node <i><b>N</b></i> has a <font color='darkBlue'>black</font> parent.
									Since any path through the parent or uncle must pass through the grandparent, the number of black nodes
									on these paths has not changed. However, the grandparent <b>G</b> may now violate properties 2
									(The root is black) or 4 (Both children of every red node are black) (property 4 possibly being violated
									since <b>G</b> may have a red parent). To fix this, the entire procedure is recursively performed on
									<b>G</b> from case 1. Note that this is a tail-recursive call, so it could be rewritten as a loop; since
									this is the only loop, and any rotations occur after this loop, this proves that a constant number of
								rotations occur. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>N: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be inserted or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="insertcase4" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> insert<wbr>Case4</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">insert<wbr>Case4<span class="tsd-signature-symbol">(</span>N<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L314">base/tree/XTree.ts:314</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> <i><b>N</b></i> is added to right of left child of grandparent, or <i><b>N</b></i> is added to left
										of right child of grandparent (<b>P</b> is <font color='red'>red</font> and <b>U</b> is
									<font color='darkBlue'>black</font>). </p>
								</div>
								<p> The parent P is red but the uncle U is black; also, the current node N is the right child of P,
									and P in turn is the left child of its parent G. In this case, a left rotation on P that switches the
									roles of the current node N and its parent P can be performed; then, the former parent node P is dealt
									with using case 5 (relabeling N and P) because property 4 (both children of every red node are black) is
									still violated. The rotation causes some paths (those in the sub-tree labelled &quot;1&quot;) to pass through the
									node N where they did not before. It also causes some paths (those in the sub-tree labelled &quot;3&quot;) not to
									pass through the node P where they did before. However, both of these nodes are red, so property 5
									(all paths from any given node to its leaf nodes contain the same number of black nodes) is not violated
									by the rotation. After this case has been completed, property 4 (both children of every red node are
								black) is still violated, but now we can resolve this by continuing to case 5. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>N: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be inserted or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="insertcase5" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> insert<wbr>Case5</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">insert<wbr>Case5<span class="tsd-signature-symbol">(</span>N<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L347">base/tree/XTree.ts:347</a></li>
								</ul>
							</aside>
							<div class="tsd-comment tsd-typography">
								<div class="lead">
									<p> <i><b>N</b></i> is added to left of left child of grandparent, or <i><b>N</b></i> is added to right
										of right child of grandparent (<b>P</b> is <font color='red'>red</font> and <b>U</b> is
									<font color='darkBlue'>black</font>). </p>
								</div>
								<p> The parent P is red but the uncle U is black, the current node N is the left child of P, and P is
									the left child of its parent G. In this case, a right rotation on G is performed; the result is a tree
									where the former parent P is now the parent of both the current node N and the former grandparent G.
									G is known to be black, since its former child P could not have been red otherwise (without violating
									property 4). Then, the colors of P and G are switched, and the resulting tree satisfies property 4
									(both children of every red node are black). Property 5 (all paths from any given node to its leaf nodes
									contain the same number of black nodes) also remains satisfied, since all paths that went through any of
									these three nodes went through G before, and now they all go through P. In each case, this is the only
								black node of the three. </p>
							</div>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>N: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
									<div class="tsd-comment tsd-typography">
										<p>A node to be inserted or swapped.</p>
									</div>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class">
					<a name="isequals" class="tsd-anchor"></a>
					<h3>is<wbr>Equals</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class">
						<li class="tsd-signature tsd-kind-icon">is<wbr>Equals<span class="tsd-signature-symbol">(</span>left<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">T</span>, right<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">boolean</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L133">base/tree/XTree.ts:133</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>left: <span class="tsd-signature-type">T</span></h5>
								</li>
								<li>
									<h5>right: <span class="tsd-signature-type">T</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">boolean</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class">
					<a name="isless" class="tsd-anchor"></a>
					<h3>is<wbr>Less</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class">
						<li class="tsd-signature tsd-kind-icon">is<wbr>Less<span class="tsd-signature-symbol">(</span>left<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">T</span>, right<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">boolean</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L135">base/tree/XTree.ts:135</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>left: <span class="tsd-signature-type">T</span></h5>
								</li>
								<li>
									<h5>right: <span class="tsd-signature-type">T</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">boolean</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="replacenode" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> replace<wbr>Node</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">replace<wbr>Node<span class="tsd-signature-symbol">(</span>oldNode<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span>, newNode<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L690">base/tree/XTree.ts:690</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>oldNode: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
								<li>
									<h5>newNode: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="rotateleft" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> rotate<wbr>Left</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">rotate<wbr>Left<span class="tsd-signature-symbol">(</span>node<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L664">base/tree/XTree.ts:664</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>node: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-private">
					<a name="rotateright" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagPrivate">Private</span> rotate<wbr>Right</h3>
					<ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-private">
						<li class="tsd-signature tsd-kind-icon">rotate<wbr>Right<span class="tsd-signature-symbol">(</span>node<span class="tsd-signature-symbol">: </span><a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li>
					</ul>
					<ul class="tsd-descriptions">
						<li class="tsd-description">
							<aside class="tsd-sources">
								<ul>
									<li>Defined in <a href="https://github.com/samchon/stl/blob/master/ts/std/base/tree/XTree.ts#L677">base/tree/XTree.ts:677</a></li>
								</ul>
							</aside>
							<h4 class="tsd-parameters-title">Parameters</h4>
							<ul class="tsd-parameters">
								<li>
									<h5>node: <a href="std.base.tree.xtreenode.html" class="tsd-signature-type">XTreeNode</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">T</span><span class="tsd-signature-symbol">&gt;</span></h5>
								</li>
							</ul>
							<h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4>
						</li>
					</ul>
				</section>
			</section>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="../globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-module">
						<a href="../modules/std.html">std</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.base.html">std.base</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.base.container.html">std.base.container</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.base.hash.html">std.base.hash</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.base.system.html">std.base.system</a>
					</li>
					<li class="current tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.base.tree.html">std.base.tree</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.example.html">std.example</a>
					</li>
					<li class=" tsd-kind-module tsd-parent-kind-module">
						<a href="../modules/std.system.html">std.system</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class tsd-parent-kind-module tsd-has-type-parameter">
						<a href="std.base.tree.atomictree.html" class="tsd-kind-icon">Atomic<wbr>Tree</a>
					</li>
					<li class=" tsd-kind-class tsd-parent-kind-module">
						<a href="std.base.tree.color.html" class="tsd-kind-icon">Color</a>
					</li>
					<li class=" tsd-kind-class tsd-parent-kind-module tsd-has-type-parameter">
						<a href="std.base.tree.pairtree.html" class="tsd-kind-icon">Pair<wbr>Tree</a>
					</li>
				</ul>
				<ul class="current">
					<li class="current tsd-kind-class tsd-parent-kind-module tsd-has-type-parameter">
						<a href="std.base.tree.xtree.html" class="tsd-kind-icon">XTree</a>
						<ul>
							<li class=" tsd-kind-constructor tsd-parent-kind-class">
								<a href="std.base.tree.xtree.html#constructor" class="tsd-kind-icon">constructor</a>
							</li>
							<li class=" tsd-kind-property tsd-parent-kind-class tsd-is-protected">
								<a href="std.base.tree.xtree.html#root" class="tsd-kind-icon">root</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class">
								<a href="std.base.tree.xtree.html#erase" class="tsd-kind-icon">erase</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#erasecase1" class="tsd-kind-icon">erase<wbr>Case1</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#erasecase2" class="tsd-kind-icon">erase<wbr>Case2</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#erasecase3" class="tsd-kind-icon">erase<wbr>Case3</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#erasecase4" class="tsd-kind-icon">erase<wbr>Case4</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#erasecase5" class="tsd-kind-icon">erase<wbr>Case5</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#erasecase6" class="tsd-kind-icon">erase<wbr>Case6</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#fetchcolor" class="tsd-kind-icon">fetch<wbr>Color</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#fetchmaximum" class="tsd-kind-icon">fetch<wbr>Maximum</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class">
								<a href="std.base.tree.xtree.html#find" class="tsd-kind-icon">find</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class">
								<a href="std.base.tree.xtree.html#insert" class="tsd-kind-icon">insert</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#insertcase1" class="tsd-kind-icon">insert<wbr>Case1</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#insertcase2" class="tsd-kind-icon">insert<wbr>Case2</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#insertcase3" class="tsd-kind-icon">insert<wbr>Case3</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#insertcase4" class="tsd-kind-icon">insert<wbr>Case4</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#insertcase5" class="tsd-kind-icon">insert<wbr>Case5</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class">
								<a href="std.base.tree.xtree.html#isequals" class="tsd-kind-icon">is<wbr>Equals</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class">
								<a href="std.base.tree.xtree.html#isless" class="tsd-kind-icon">is<wbr>Less</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#replacenode" class="tsd-kind-icon">replace<wbr>Node</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#rotateleft" class="tsd-kind-icon">rotate<wbr>Left</a>
							</li>
							<li class=" tsd-kind-method tsd-parent-kind-class tsd-is-private">
								<a href="std.base.tree.xtree.html#rotateright" class="tsd-kind-icon">rotate<wbr>Right</a>
							</li>
						</ul>
					</li>
				</ul>
				<ul class="after-current">
					<li class=" tsd-kind-class tsd-parent-kind-module tsd-has-type-parameter">
						<a href="std.base.tree.xtreenode.html" class="tsd-kind-icon">XTree<wbr>Node</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.io" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="../assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="../assets/js/search.js"><' + '/script>');</script>
</body>
</html>