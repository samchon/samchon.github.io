<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.10">
  <compounddef id="db/d64/namespacesamchon_1_1protocol" kind="namespace" language="C++">
    <compoundname>samchon::protocol</compoundname>
    <innerclass refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" prot="public">samchon::protocol::Entity</innerclass>
    <innerclass refid="dc/d8d/classsamchon_1_1protocol_1_1EntityArray" prot="public">samchon::protocol::EntityArray</innerclass>
    <innerclass refid="d4/deb/classsamchon_1_1protocol_1_1EntityGroup" prot="public">samchon::protocol::EntityGroup</innerclass>
    <innerclass refid="d6/d5a/classsamchon_1_1protocol_1_1EntityList" prot="public">samchon::protocol::EntityList</innerclass>
    <innerclass refid="dc/dfd/classsamchon_1_1protocol_1_1ExternalClient" prot="public">samchon::protocol::ExternalClient</innerclass>
    <innerclass refid="d8/d47/classsamchon_1_1protocol_1_1ExternalClientArray" prot="public">samchon::protocol::ExternalClientArray</innerclass>
    <innerclass refid="df/d4a/classsamchon_1_1protocol_1_1ExternalServer" prot="public">samchon::protocol::ExternalServer</innerclass>
    <innerclass refid="d1/de5/classsamchon_1_1protocol_1_1ExternalServerArray" prot="public">samchon::protocol::ExternalServerArray</innerclass>
    <innerclass refid="df/d42/classsamchon_1_1protocol_1_1ExternalSystem" prot="public">samchon::protocol::ExternalSystem</innerclass>
    <innerclass refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray" prot="public">samchon::protocol::ExternalSystemArray</innerclass>
    <innerclass refid="d4/db7/classsamchon_1_1protocol_1_1ExternalSystemRole" prot="public">samchon::protocol::ExternalSystemRole</innerclass>
    <innerclass refid="d2/d55/classsamchon_1_1protocol_1_1FlashPolicyServer" prot="public">samchon::protocol::FlashPolicyServer</innerclass>
    <innerclass refid="d3/dc8/classsamchon_1_1protocol_1_1IClient" prot="public">samchon::protocol::IClient</innerclass>
    <innerclass refid="d3/d66/classsamchon_1_1protocol_1_1IEntityChain" prot="public">samchon::protocol::IEntityChain</innerclass>
    <innerclass refid="d9/d4c/classsamchon_1_1protocol_1_1IEntityGroup" prot="public">samchon::protocol::IEntityGroup</innerclass>
    <innerclass refid="d1/d9d/classsamchon_1_1protocol_1_1IEntityPtrGroup" prot="public">samchon::protocol::IEntityPtrGroup</innerclass>
    <innerclass refid="da/d67/classsamchon_1_1protocol_1_1IEntitySharedPtrGroup" prot="public">samchon::protocol::IEntitySharedPtrGroup</innerclass>
    <innerclass refid="da/d03/classsamchon_1_1protocol_1_1IEntityUniquePtrGroup" prot="public">samchon::protocol::IEntityUniquePtrGroup</innerclass>
    <innerclass refid="db/dae/classsamchon_1_1protocol_1_1IHTMLEntity" prot="public">samchon::protocol::IHTMLEntity</innerclass>
    <innerclass refid="d8/d82/classsamchon_1_1protocol_1_1Invoke" prot="public">samchon::protocol::Invoke</innerclass>
    <innerclass refid="da/d47/classsamchon_1_1protocol_1_1InvokeHistory" prot="public">samchon::protocol::InvokeHistory</innerclass>
    <innerclass refid="d1/d7b/classsamchon_1_1protocol_1_1InvokeHistoryArray" prot="public">samchon::protocol::InvokeHistoryArray</innerclass>
    <innerclass refid="d0/d1a/classsamchon_1_1protocol_1_1InvokeParameter" prot="public">samchon::protocol::InvokeParameter</innerclass>
    <innerclass refid="d4/dcf/classsamchon_1_1protocol_1_1IProtocol" prot="public">samchon::protocol::IProtocol</innerclass>
    <innerclass refid="d4/de8/classsamchon_1_1protocol_1_1IServer" prot="public">samchon::protocol::IServer</innerclass>
    <innerclass refid="d7/d56/classsamchon_1_1protocol_1_1ISQLEntity" prot="public">samchon::protocol::ISQLEntity</innerclass>
    <innerclass refid="d7/d51/classsamchon_1_1protocol_1_1IWebClient" prot="public">samchon::protocol::IWebClient</innerclass>
    <innerclass refid="d5/d23/classsamchon_1_1protocol_1_1IWebServer" prot="public">samchon::protocol::IWebServer</innerclass>
    <innerclass refid="db/d72/classsamchon_1_1protocol_1_1ServerConnector" prot="public">samchon::protocol::ServerConnector</innerclass>
    <innerclass refid="d5/de8/classsamchon_1_1protocol_1_1SystemRole" prot="public">samchon::protocol::SystemRole</innerclass>
    <innerclass refid="d8/dc2/classsamchon_1_1protocol_1_1WebServerConnector" prot="public">samchon::protocol::WebServerConnector</innerclass>
    <innernamespace refid="de/dc0/namespacesamchon_1_1protocol_1_1master">samchon::protocol::master</innernamespace>
    <innernamespace refid="d8/d70/namespacesamchon_1_1protocol_1_1service">samchon::protocol::service</innernamespace>
    <innernamespace refid="db/d33/namespacesamchon_1_1protocol_1_1slave">samchon::protocol::slave</innernamespace>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="db/d64/namespacesamchon_1_1protocol_1aad78260d3d142da970db113839ab3e52" prot="public" static="no">
        <type><ref refid="d4/deb/classsamchon_1_1protocol_1_1EntityGroup" kindref="compound">EntityGroup</ref>&lt; std::vector&lt; std::shared_ptr&lt; _Ty &gt;&gt;, _Ty, std::shared_ptr&lt; _Ty &gt; &gt;</type>
        <definition>SharedEntityArray</definition>
        <argsstring></argsstring>
        <name>SharedEntityArray</name>
        <briefdescription>
<para>An <ref refid="d4/deb/classsamchon_1_1protocol_1_1EntityGroup" kindref="compound">EntityGroup</ref> with vector container and children capsuled in shared pointers. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>_Ty</parametername>
</parameternamelist>
<parameterdescription>
<para>A type of children <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref>. Must be a class derived from an <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref> or <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref> itself.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para><para>For a case of inheritance of SharedEntityArray and the inherited SharedEntityArray also contains entity objects which are inherited from original child entity type, SharedEntityArray supports macros changing returned type of accessor methods. </para><para><itemizedlist>
<listitem><para>SHARED_ENTITY_ARRAY_ELEMENT_ACCESSOR_HEADER </para></listitem>
<listitem><para>SHARED_ENTITY_ARRAY_ELEMENT_ACCESSOR_BODY</para></listitem>
</itemizedlist>
<simplesect kind="see"><para><ref refid="db/d64/namespacesamchon_1_1protocol" kindref="compound">samchon::protocol</ref> </para></simplesect>
<simplesect kind="author"><para>Jeongho Nam </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/SharedEntityArray.hpp" line="27" column="1" bodyfile="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/SharedEntityArray.hpp" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="db/d64/namespacesamchon_1_1protocol_1a45d013b8bd41de47dc445260d9f5417e" prot="public" static="no">
        <type><ref refid="d4/deb/classsamchon_1_1protocol_1_1EntityGroup" kindref="compound">EntityGroup</ref>&lt; std::list&lt; std::shared_ptr&lt; _Ty &gt;&gt;, _Ty, std::shared_ptr&lt; _Ty &gt; &gt;</type>
        <definition>using SharedEntityList =  EntityGroup &lt; std::list&lt;std::shared_ptr&lt;_Ty&gt;&gt;, _Ty, std::shared_ptr&lt;_Ty&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>SharedEntityList</name>
        <briefdescription>
<para>An <ref refid="d4/deb/classsamchon_1_1protocol_1_1EntityGroup" kindref="compound">EntityGroup</ref> with list container and children capsuled in shared pointers. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>_Ty</parametername>
</parameternamelist>
<parameterdescription>
<para>A type of children <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref>. Must be a class derived from an <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref> or <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref> itself.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="db/d64/namespacesamchon_1_1protocol" kindref="compound">samchon::protocol</ref> </para></simplesect>
<simplesect kind="author"><para>Jeongho Nam </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/SharedEntityList.hpp" line="19" column="1" bodyfile="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/SharedEntityList.hpp" bodystart="24" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="db/d64/namespacesamchon_1_1protocol_1ab61f9fa1d3025c7944f93b7fa49563ce" prot="public" static="no">
        <type>boost::asio::basic_stream_socket&lt; boost::asio::ip::tcp, boost::asio::stream_socket_service&lt; boost::asio::ip::tcp &gt; &gt;</type>
        <definition>typedef boost::asio::basic_stream_socket&lt; boost::asio::ip::tcp, boost::asio::stream_socket_service&lt;boost::asio::ip::tcp&gt; &gt; Socket</definition>
        <argsstring></argsstring>
        <name>Socket</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/Socket.hpp" line="32" column="1" bodyfile="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/Socket.hpp" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="db/d64/namespacesamchon_1_1protocol_1ac16b9e357ae14b34099286f0f91bb4cb" prot="public" static="no">
        <type>boost::asio::basic_socket_acceptor&lt; boost::asio::ip::tcp &gt;</type>
        <definition>typedef boost::asio::basic_socket_acceptor&lt;boost::asio::ip::tcp&gt; Acceptor</definition>
        <argsstring></argsstring>
        <name>Acceptor</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/Socket.hpp" line="34" column="1" bodyfile="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/Socket.hpp" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="db/d64/namespacesamchon_1_1protocol_1a000087642c6955477f02be84ef50a5b1" prot="public" static="no">
        <type>boost::asio::ip::basic_endpoint&lt; boost::asio::ip::tcp &gt;</type>
        <definition>typedef boost::asio::ip::basic_endpoint&lt;boost::asio::ip::tcp&gt; EndPoint</definition>
        <argsstring></argsstring>
        <name>EndPoint</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/Socket.hpp" line="35" column="1" bodyfile="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/Socket.hpp" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="db/d64/namespacesamchon_1_1protocol_1ab6fc7d36b7aea823c7eb5d7c3a12b714" prot="public" static="no">
        <type><ref refid="d4/deb/classsamchon_1_1protocol_1_1EntityGroup" kindref="compound">EntityGroup</ref>&lt; std::vector&lt; std::unique_ptr&lt; _Ty &gt;&gt;, _Ty, std::unique_ptr&lt; _Ty &gt; &gt;</type>
        <definition>using UniqueEntityArray =  EntityGroup &lt; std::vector&lt;std::unique_ptr&lt;_Ty&gt;&gt;, _Ty, std::unique_ptr&lt;_Ty&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>UniqueEntityArray</name>
        <briefdescription>
<para>An <ref refid="d4/deb/classsamchon_1_1protocol_1_1EntityGroup" kindref="compound">EntityGroup</ref> with vector container and children capsuled in unique pointers. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>_Ty</parametername>
</parameternamelist>
<parameterdescription>
<para>A type of children <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref>. Must be a class derived from an <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref> or <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref> itself.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para><para>For a case of inheritance of UniqueEntityArray and the inherited UniqueEntityArray also contains entity objects which are inherited from original child entity type, UniqueEntityArray supports macros changing returned type of accessor methods. </para><para><itemizedlist>
<listitem><para>UNIQUE_ENTITY_ARRAY_ELEMENT_ACCESSOR_HEADER </para></listitem>
<listitem><para>UNIQUE_ENTITY_ARRAY_ELEMENT_ACCESSOR_BODY</para></listitem>
</itemizedlist>
<simplesect kind="note"><para></para></simplesect>
std::unique_ptr doesn&apos;t allow copy construction. It allows only move construction. When inserts children objcets not by construct() method but by your hand, Be careful to insert deriving copy construction. You&apos;ve use move constructor. </para><para><itemizedlist>
<listitem><para><emphasis> UniqueEntityArray&lt;?&gt;::push_back( move( std::unique_ptr&lt;?&gt;(new ?(...)) ) ); </emphasis></para></listitem>
</itemizedlist>
<simplesect kind="see"><para><ref refid="db/d64/namespacesamchon_1_1protocol" kindref="compound">samchon::protocol</ref> </para></simplesect>
<simplesect kind="author"><para>Jeongho Nam </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/UniqueEntityArray.hpp" line="34" column="1" bodyfile="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/UniqueEntityArray.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="db/d64/namespacesamchon_1_1protocol_1afc95c533631d0d80d5a4b06d0f693ca4" prot="public" static="no">
        <type><ref refid="d4/deb/classsamchon_1_1protocol_1_1EntityGroup" kindref="compound">EntityGroup</ref>&lt; std::list&lt; std::unique_ptr&lt; _Ty &gt;&gt;, _Ty, std::unique_ptr&lt; _Ty &gt; &gt;</type>
        <definition>using UniqueEntityList =  EntityGroup &lt; std::list&lt;std::unique_ptr&lt;_Ty&gt;&gt;, _Ty, std::unique_ptr&lt;_Ty&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>UniqueEntityList</name>
        <briefdescription>
<para>An <ref refid="d4/deb/classsamchon_1_1protocol_1_1EntityGroup" kindref="compound">EntityGroup</ref> with list container and children capsuled in unique pointers. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>_Ty</parametername>
</parameternamelist>
<parameterdescription>
<para>A type of children <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref>. Must be a class derived from an <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref> or <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref> itself.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para></para></simplesect>
std::unique_ptr doesn&apos;t allow copy construction. It allows only move construction. When inserts children objcets not by construct() method but by your hand, Be careful to insert deriving copy construction. You&apos;ve use move constructor. </para><para><itemizedlist>
<listitem><para><emphasis> UniqueEntityList&lt;?&gt;::push_back( move( std::unique_ptr&lt;?&gt;(new ?(...)) ) ); </emphasis></para></listitem>
</itemizedlist>
<simplesect kind="see"><para><ref refid="db/d64/namespacesamchon_1_1protocol" kindref="compound">samchon::protocol</ref> </para></simplesect>
<simplesect kind="author"><para>Jeongho Nam </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/UniqueEntityList.hpp" line="27" column="1" bodyfile="D:/OneDrive/Project/Samchon/framework/cpp/samchon/protocol/UniqueEntityList.hpp" bodystart="32" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Package of network protocol and libraries. </para>    </briefdescription>
    <detaileddescription>
<para><itemizedlist>
<listitem>
<para><heading level="3"><ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref> - data classes with utility methods </heading>
</para><para></para><para>In Samchon Framework, with entity, boundary and control, entity is the main. The entity package provides I/O interface to/from XML, <ref refid="d8/d82/classsamchon_1_1protocol_1_1Invoke" kindref="compound">Invoke</ref> and DBMS. If you need some additional function (role of boundary or control) for an entity, use chain of responsibility pattern starting from the entity. </para><para></para><para></para><para>When data-set has a &quot;hierarchical relationship&quot;, do not have the children objects by having a container member variable. Directly inherits container set. Composes the data class (entity) having children by inheriting <ref refid="d4/deb/classsamchon_1_1protocol_1_1EntityGroup" kindref="compound">EntityGroup</ref> and terminate the leaf node by inheriting <ref refid="d0/d3e/classsamchon_1_1protocol_1_1Entity" kindref="compound">Entity</ref> (single object).</para><para><image type="html" name="protocol_entity.png"></image>
 <image type="latex" name="protocol_entity.png"></image>
</para><para></para></listitem>
<listitem>
<para><heading level="3"><ref refid="d8/d82/classsamchon_1_1protocol_1_1Invoke" kindref="compound">Invoke</ref> - standard network I/O message </heading>
</para><para></para><para><ref refid="d8/d82/classsamchon_1_1protocol_1_1Invoke" kindref="compound">Invoke</ref> is a standard message structure using network I/O in Samchon Framework. </para><para></para><para></para><para>The <ref refid="d8/d82/classsamchon_1_1protocol_1_1Invoke" kindref="compound">Invoke</ref> message has an XML structure like the piacture in below. We can enjoy lots of benefits by the normalized and standardized message structure used in network I/O.<linebreak/>
 </para><para>The greatest advantage is that we can make any type of network system, even how the system is enourmously complicated. As network communication message is standardized, we only need to concentrate on logical relationships between network systems. We can handle each network system like a object (class) in OOD. And those relationships can be easily designed by using design pattern. </para><para></para><para></para><para>Furthermore, The module invoke not only provides parsing and converting from/to <ref refid="d8/d82/classsamchon_1_1protocol_1_1Invoke" kindref="compound">Invoke</ref> message, but also history classes can be used to archiving log or estimating performance of a system. The purpose of estimating performance a system, especially, used in module of distributed processing and parallel processing systems. </para><para></para><para><image type="html" name="protocol_invoke.png"></image>
 <image type="latex" name="protocol_invoke.png"></image>
</para><para></para></listitem>
<listitem>
<para><heading level="3">Intefaces </heading>
</para><para></para><para>You can make any type of network system with only three + one interfaces; <ref refid="d4/dcf/classsamchon_1_1protocol_1_1IProtocol" kindref="compound">IProtocol</ref>, <ref refid="d4/de8/classsamchon_1_1protocol_1_1IServer" kindref="compound">IServer</ref> and <ref refid="d3/dc8/classsamchon_1_1protocol_1_1IClient" kindref="compound">IClient</ref> + <ref refid="db/d72/classsamchon_1_1protocol_1_1ServerConnector" kindref="compound">ServerConnector</ref> which are called basic 3 + 1 components. As I&apos;ve mentiond in previous invoke module, because of standardization of message of network I/O, we only need to concentrate on logical relationship like handling OOD objects </para><para></para><para></para><para>The basic 3 + 1 components are top level abstract interfaces for designing network system like handling OOD objects. When you see the protocol module from a different view, out of framework, you can find that all the other classes in protocol are another examples combinationing and utilizing those basic 3 + 1 components (interaces). </para><para></para><para></para><para><image type="html" name="protocol_interface.png"></image>
 <image type="latex" name="protocol_interface.png"></image>
</para><para></para><para><image type="html" name="send_invoke.png"></image>
 <image type="latex" name="send_invoke.png"></image>
</para><para></para></listitem>
<listitem>
<para><heading level="3">External System </heading>
</para><para></para><para>Module <emphasis>external_system</emphasis> provides interfaces for interaction with external network system. Although, the module <emphasis>external_system</emphasis> acts boundary as main role, what you&apos;ve to concentrate on is the entity. Samchon Framework takes responsibility of network communication and you only consider about relationship and role of each <emphasis>external network systems</emphasis>. </para><para></para><para></para><para><ref refid="df/d42/classsamchon_1_1protocol_1_1ExternalSystem" kindref="compound">ExternalSystem</ref> objects are managed by <ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray" kindref="compound">ExternalSystemArray</ref> and the <ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray" kindref="compound">ExternalSystemArray</ref> can access to an <ref refid="d4/db7/classsamchon_1_1protocol_1_1ExternalSystemRole" kindref="compound">ExternalSystemRole</ref> belongs to an <ref refid="df/d42/classsamchon_1_1protocol_1_1ExternalSystem" kindref="compound">ExternalSystem</ref> directly. When you send an <ref refid="d8/d82/classsamchon_1_1protocol_1_1Invoke" kindref="compound">Invoke</ref> message to <ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray" kindref="compound">ExternalSystemArray</ref>, the <ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray" kindref="compound">ExternalSystemArray</ref> finds matched <ref refid="d4/db7/classsamchon_1_1protocol_1_1ExternalSystemRole" kindref="compound">ExternalSystemRole</ref> and the <ref refid="d4/db7/classsamchon_1_1protocol_1_1ExternalSystemRole" kindref="compound">ExternalSystemRole</ref> shifts the network I/O responsibility to belonged <ref refid="df/d42/classsamchon_1_1protocol_1_1ExternalSystem" kindref="compound">ExternalSystem</ref>. </para><para></para><para></para><para>The relationship called as &quot;Proxy Pattern&quot;. With the pattern, &quot;Proxy&quot;, you can concentrate on roles irrespective of where each role is belonged to (you can only concentrate on <ref refid="d4/db7/classsamchon_1_1protocol_1_1ExternalSystemRole" kindref="compound">ExternalSystemRole</ref> itself, what to do with <ref refid="d8/d82/classsamchon_1_1protocol_1_1Invoke" kindref="compound">Invoke</ref> message, irrespective of the <ref refid="d4/db7/classsamchon_1_1protocol_1_1ExternalSystemRole" kindref="compound">ExternalSystemRole</ref> is belonged to which <ref refid="df/d42/classsamchon_1_1protocol_1_1ExternalSystem" kindref="compound">ExternalSystem</ref>). </para><para></para><para><itemizedlist>
<listitem>
<para><ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray_1ae0f466a169b2d23786a2f94ac908672c" kindref="member">ExternalSystemArray::sendData()</ref> -&gt; ExternalSystemRole(Proxy)::sendData() -&gt; <ref refid="d3/dc8/classsamchon_1_1protocol_1_1IClient_1a7e9e36d7847d933abbf3b1eda35aab0d" kindref="member">ExternalSystem::sendData()</ref>  </para></listitem>
<listitem>
<para><ref refid="df/d42/classsamchon_1_1protocol_1_1ExternalSystem_1a5b0e5be870f2d6a26004a8e637a1ce6c" kindref="member">ExternalSystem::replyData()</ref> -&gt; ExternalSystemRole(Proxy)::replyData()  </para></listitem>
</itemizedlist>
</para><para></para><para>Whether using the &quot;Proxy pattern&quot; is on your mind in <emphasis>external_system module</emphasis> level. &quot;Proxy pattern&quot; is recommend to use in <emphasis>external_system</emphasis> module, but not forced. However, since <emphasis>parallel_processing_system</emphasis> module, you&apos;ve to follow the pattern.</para><para><image type="html" name="protocol_external_system.png"></image>
 <image type="latex" name="protocol_external_system.png"></image>
</para><para></para></listitem>
<listitem>
<para><heading level="3">Packages in protocol </heading>
</para><para><itemizedlist>
<listitem>
<para><heading level="4">Cloud service </heading>
</para><para></para><para>The &quot;service&quot; package is for realizing cloud service. </para><para></para><para></para><para>In Samchon Framework, realizing cloud service, there&apos;re two classes representing physical server and client as <ref refid="d9/d35/classsamchon_1_1protocol_1_1service_1_1Server" kindref="compound">service::Server</ref> and <ref refid="df/d31/classsamchon_1_1protocol_1_1service_1_1Client" kindref="compound">service::Client</ref>. Between the two classes representing boundaries, there is a class representing logical conception user as <ref refid="df/d87/classsamchon_1_1protocol_1_1service_1_1User" kindref="compound">service::User</ref>. In the terminal node under the <ref refid="df/d31/classsamchon_1_1protocol_1_1service_1_1Client" kindref="compound">service::Client</ref>, <ref refid="d6/df3/classsamchon_1_1protocol_1_1service_1_1Service" kindref="compound">service::Service</ref> class represents a control. </para><para></para><para></para><para>The default protocol of the service package is not &apos;web socket&apos;. The default only has message protocol of <ref refid="d8/d82/classsamchon_1_1protocol_1_1Invoke" kindref="compound">Invoke</ref>, does not have handshake or another pre-defined protocol. By the default protocol, you can connect to the cloud server (built from c++, by service package) as a client by a program or plug-in like Flex or C#. However you can&apos;t connect by web-browser only allowing socket protocol as web-socket. </para><para></para><para></para><para>To build a cloud service to follow web-socket protocol, inherits derviced classes not from <ref refid="d9/d35/classsamchon_1_1protocol_1_1service_1_1Server" kindref="compound">service::Server</ref>, <ref refid="df/d31/classsamchon_1_1protocol_1_1service_1_1Client" kindref="compound">service::Client</ref>, but from service::WebServer, service::WebClient or implements <ref refid="d5/d23/classsamchon_1_1protocol_1_1IWebServer" kindref="compound">IWebServer</ref>, <ref refid="d7/d51/classsamchon_1_1protocol_1_1IWebClient" kindref="compound">IWebClient</ref> which are derived from <ref refid="d9/d35/classsamchon_1_1protocol_1_1service_1_1Server" kindref="compound">service::Server</ref> and <ref refid="df/d31/classsamchon_1_1protocol_1_1service_1_1Client" kindref="compound">service::Client</ref>. </para><para></para><para><heading level="5">Class Diagram </heading>
</para><para></para><para><image type="html" name="protocol_service.png"></image>
 <image type="latex" name="protocol_service.png"></image>
</para><para><heading level="5">Sequence Diagram - A client&apos;s connection </heading>
</para><para></para><para><image type="html" name="service_connection.png"></image>
 <image type="latex" name="service_connection.png"></image>
</para><para><heading level="5">Sequence Diagram - Network communication </heading>
</para><para></para><para><image type="html" name="service_communication.png"></image>
 <image type="latex" name="service_communication.png"></image>
</para><para></para></listitem>
<listitem>
<para><heading level="4">Master system </heading>
</para><para></para><para></para><para><image type="html" name="distributed_and_parallel_processing_system.png"></image>
 <image type="latex" name="distributed_and_parallel_processing_system.png"></image>
</para><para></para><para>In master package, provides distributed and parallel processing system modules which are in framework of master. With classes in master package, you can realize any type of distributed or parallel processing system in master side, even how enormouse scale those have. </para><para></para><para><heading level="5">Distributed Processing System </heading>
</para><para></para><para>A distributed processing system of master, a master (<ref refid="d3/d88/classsamchon_1_1protocol_1_1master_1_1DistributedSystemArray" kindref="compound">master::DistributedSystemArray</ref>) allocates roles (<ref refid="d1/d16/classsamchon_1_1protocol_1_1master_1_1DistributedSystemRole" kindref="compound">master::DistributedSystemRole</ref>) to systems (<ref refid="db/d2d/classsamchon_1_1protocol_1_1master_1_1DistributedSystem" kindref="compound">master::DistributedSystem</ref>). User does not consider about which roles are allocated to which systems. User just accesses to a <emphasis>role</emphasis> and send or reply message from those roles.</para><para><itemizedlist>
<listitem>
<para>It&apos;s the proxy pattern have mentioned in external system </para><para><ref refid="df/d42/classsamchon_1_1protocol_1_1ExternalSystem" kindref="compound">ExternalSystem</ref> objects are managed by <ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray" kindref="compound">ExternalSystemArray</ref> and the <ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray" kindref="compound">ExternalSystemArray</ref> can access to a role belongs to a system directly. When you send an <ref refid="d8/d82/classsamchon_1_1protocol_1_1Invoke" kindref="compound">Invoke</ref> message to <ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray" kindref="compound">ExternalSystemArray</ref>, the <ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray" kindref="compound">ExternalSystemArray</ref> finds matched <ref refid="d4/db7/classsamchon_1_1protocol_1_1ExternalSystemRole" kindref="compound">ExternalSystemRole</ref> and the <ref refid="d4/db7/classsamchon_1_1protocol_1_1ExternalSystemRole" kindref="compound">ExternalSystemRole</ref> shifts the network I/O responsibility to belonged <ref refid="df/d42/classsamchon_1_1protocol_1_1ExternalSystem" kindref="compound">ExternalSystem</ref>. This relationship called &quot;Proxy Pattern&quot;. By the pattern, &quot;Proxy&quot;, you can concentrate on roles irrespective of where each role is belonged to. </para><para></para><para><itemizedlist>
<listitem>
<para><ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray_1ae0f466a169b2d23786a2f94ac908672c" kindref="member">ExternalSystemArray::sendData()</ref> -&gt; ExternalSystemRole(Proxy)::sendData() -&gt; <ref refid="d3/dc8/classsamchon_1_1protocol_1_1IClient_1a7e9e36d7847d933abbf3b1eda35aab0d" kindref="member">ExternalSystem::sendData()</ref>  </para></listitem>
<listitem>
<para><ref refid="df/d42/classsamchon_1_1protocol_1_1ExternalSystem_1a5b0e5be870f2d6a26004a8e637a1ce6c" kindref="member">ExternalSystem::replyData()</ref> -&gt; ExternalSystemRole(Proxy)::replyData()  </para></listitem>
</itemizedlist>
</para></listitem>
</itemizedlist>
</para><para></para><para>However, unlike the case of managing roles from <ref refid="d9/dc6/classsamchon_1_1protocol_1_1ExternalSystemArray" kindref="compound">ExternalSystemArray</ref>, in DistributedSystemArray, roles can be allocated in multiple systems duplicately. And the roles can be moved to another systems. Those management and allocation of roles are determined by estimation of performance of each system, and required performance of each role. </para><para></para><para></para><para><image type="html" name="protocol_master_distributed_system.png"></image>
 <image type="latex" name="protocol_master_distributed_system.png"></image>
</para><para><heading level="5">Parallel Processing System </heading>
</para><para></para><para>Unlike distributed processing system, the parallel processing system is not complicate. It has very simple logic. About requested processes, master(master::ParallelSystemArray) allocates each process to each slave system by their own performance index have estimated. </para><para></para><para></para><para><image type="html" name="protocol_master_parallel_system.png"></image>
 <image type="latex" name="protocol_master_parallel_system.png"></image>
</para><para></para></listitem>
<listitem>
<para><heading level="4">Slave system </heading>
</para><para></para><para>A package for composing distributed or parallel processing system in slave side. </para><para></para><para>Slave system get orders from master, processes the orders and report the result with its elapsed time for estimating performance of the slave system. </para><para></para><para><image type="html" name="protocol_slave.png"></image>
 <image type="latex" name="protocol_slave.png"></image>
</para><para></para></listitem>
</itemizedlist>
</para></listitem>
</itemizedlist>
</para><para><simplesect kind="note"><para><itemizedlist>
<listitem><para>Boost Libraries: <ulink url="http://www.boost.org/">http://www.boost.org/</ulink> </para></listitem>
<listitem><para>Boot.Asio: <ulink url="http://www.boost.org/doc/libs/1_59_0/doc/html/boost_asio.html">http://www.boost.org/doc/libs/1_59_0/doc/html/boost_asio.html</ulink></para></listitem>
</itemizedlist>
</para></simplesect>
<simplesect kind="author"><para>Jeongho Nam </para></simplesect>
</para>    </detaileddescription>
    <location file="D:/OneDrive/Project/Samchon/framework/cpp/samchon/documentation/master.hpp" line="6" column="1"/>
  </compounddef>
</doxygen>
