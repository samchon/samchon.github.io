.TH "EntityGroup< _Container, _ETy, _Ty >" 3 "Mon Oct 26 2015" "Version 1.0.0" "Samchon Framework for CPP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
EntityGroup< _Container, _ETy, _Ty > \- An \fBEntity\fP and a container of children \fBEntity\fP objects\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <EntityGroup\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBEntityGroup\fP ()"
.br
.RI "\fIDefault Constructor\&. \fP"
.ti -1c
.RI "virtual void \fBconstruct\fP (std::shared_ptr< \fBlibrary::XML\fP > xml)"
.br
.RI "\fIConstruct data of the \fBEntity\fP from an XML object\&. \fP"
.ti -1c
.RI "auto \fBhas\fP (const std::string &\fBkey\fP) const  \-> bool"
.br
.RI "\fIIndicates whether a container has an object having the specified identifier\&. \fP"
.ti -1c
.RI "auto \fBget\fP (const std::string &\fBkey\fP) \-> value_type &"
.br
.RI "\fIAccess the element by specified identifier(key)\&. \fP"
.ti -1c
.RI "auto \fBget\fP (const std::string &\fBkey\fP) const  \-> const value_type &"
.br
.RI "\fIAccess the const element by specified identifier(key)\&. \fP"
.ti -1c
.RI "virtual auto \fBtoXML\fP () const  \-> std::shared_ptr< \fBlibrary::XML\fP >"
.br
.RI "\fIGet an XML object represents the \fBEntityGroup\fP\&. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual auto \fBcreateChild\fP (std::shared_ptr< \fBlibrary::XML\fP >) \-> entity_type *=0"
.br
.RI "\fIFactory method of a child \fBEntity\fP\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Container, typename _ETy = Entity, typename _Ty = _Container::value_type>class samchon::protocol::EntityGroup< _Container, _ETy, _Ty >"
An \fBEntity\fP and a container of children \fBEntity\fP objects\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Container\fP A type of container containing children entity objects\&. 
.br
\fI_Ety\fP A type of children entity\&. It must be a class derived from an \fBEntity\fP class, or \fBEntity\fP class itself\&. 
.br
\fI_Ty\fP A type of children element of _Container\&. Using default template parameter is recommended\&.
.RE
.PP
.PP
\fBEntityGroup\fP is a template class for containinig children \fBEntity\fP objects, and also another type of an \fBEntity\fP, too\&. You can realize hierarchical relationship\&. Although some entities have complicated hierarchical relationship, you can deduct a optimal solution easily with \fBEntityGroup\fP and \fBEntity\fP\&. 
.PP
If an entity has some subordinate entities of same type, they are in 'Composite relationship'\&. Make the entity to be EmntityGroup and subordinate entities to be children of the entity\&. When those relationships are continued, continue to create classes dervied from \fBEntityGroup\fP\&. When those relationshiop meets a terminal node, then make the terminal node to be an \fBEntity\fP\&. 
.PP
 
.PP
\fBEntityGroup\fP is an \fBEntity\fP, and a container of children \fBEntity\fP objects at the same time\&. If children type, of a class derived from an \fBEntityGroup\fP, is itself, you can realize hierarchical and recursive relationship\&. The relationship is called as 'Composite pattern'\&. 
.PP
.PD 0
.IP "\(bu" 2
FTFolder extends FTInstance and SharedEntityArray<FTInstance> 
.IP "\(bu" 2
NTCriteria extends SharedEntityArray<NTCriteria>
.PP
\fBNote:\fP
.RS 4
.RE
.PP
As a freelancer developer and architect I am, I even design DB I/O to follow the format representing \fBEntity\fP and \fBEntityGroup\fP by XML\&. Below T-SQL script also follows the standard format of expressing \fBEntity\fP with XML by procedure and 'FOR XML AUTO' statement\&. 
.PP
.PP
.nf
1 SET 
2   ANSI_NULLS, 
3   QUOTED_IDENTIFIER, 
4   CONCAT_NULL_YIELDS_NULL, 
5   ANSI_WARNINGS, 
6   ANSI_PADDING 
7 ON;
8 
9 USE OraQ;
10 IF OBJECT_ID('v_studyStatus') IS NOT NULL           DROP VIEW v_studyStatus;
11 IF OBJECT_ID('v_nonDicomFileStatus') IS NOT NULL    DROP VIEW v_nonDicomFileStatus;
12 IF OBJECT_ID('v_candidateStudy') IS NOT NULL        DROP VIEW v_candidateStudy;
13 IF OBJECT_ID('v_candidateFile') IS NOT NULL         DROP VIEW v_candidateFile;
14 IF OBJECT_ID('goCandidateInspectList') IS NOT NULL  DROP PROCEDURE goCandidateInspectList;
15 GO
16 
17 CREATE VIEW v_studyStatus
18 AS
19     WITH cte AS
20     (
21         SELECT S\&.studyUID uid, S\&.type type, ROW_NUMBER() OVER (PARTITION BY S\&.studyUID ORDER BY H\&.datetime DESC) no
22         FROM History\&.history H, History\&.study S
23         WHERE
24             H\&.uid = S\&.uid AND type <> 1
25     )
26     SELECT 
27         A\&.uid, 
28         CASE WHEN B\&.type IS NULL THEN
29             A\&.type
30             ELSE 1
31         END status
32     FROM
33     (
34         SELECT uid, type
35         FROM cte
36         WHERE no = 1
37     ) A LEFT OUTER JOIN
38     (
39         SELECT studyUID uid, 1 type
40         FROM History\&.study
41         GROUP BY studyUID
42         HAVING MAX(type) = 1
43     ) B ON A\&.uid = B\&.uid
44 GO
45 CREATE VIEW v_nonDicomFileStatus
46 AS
47     WITH cte AS
48     (
49         SELECT
50             F\&.fileUID uid, F\&.type type, 
51             ROW_NUMBER() OVER (PARTITION BY F\&.fileUID ORDER BY H\&.datetime DESC) no
52         FROM History\&.history H, History\&.nonDicomFile F
53         WHERE
54             H\&.uid = F\&.uid AND type <> 1
55     )
56     SELECT 
57         A\&.uid, 
58         CASE WHEN B\&.type IS NULL THEN
59             A\&.type
60             ELSE 1
61         END status
62     FROM
63     (
64         SELECT uid, type
65         FROM cte
66         WHERE no = 1
67     ) A LEFT OUTER JOIN
68     (
69         SELECT fileUID uid, 1 type
70         FROM History\&.nonDicomFile
71         GROUP BY fileUID
72         HAVING MAX(type) = 1
73     ) B ON A\&.uid = B\&.uid
74 GO
75 CREATE VIEW v_candidateStudy
76 AS
77     SELECT DISTINCT
78         P\&.id patientID, 
79             P\&.name patientName, P\&.gender patientGender, 
80             CAST(P\&.birthdate AS DATE) patientBirthdate,
81         S\&.uid, 
82             S\&.description, 
83             CONVERT(VARCHAR, CAST(S\&.datetime AS DATETIME), 120) AS datetime,
84             H\&.status
85     FROM
86         Hospital\&.patient P, Inspect\&.media M, Inspect\&.mediaStudyPair A, 
87         Inspect\&.study S, v_studyStatus H
88     WHERE
89         P\&.id = M\&.patientID AND M\&.uid = A\&.mediaUID AND A\&.studyUID = S\&.uid AND 
90         S\&.uid = H\&.uid
91 GO
92 CREATE VIEW v_candidateFile
93 AS
94     SELECT DISTINCT
95         P\&.id patientID, 
96             P\&.name patientName, P\&.gender patientGender, 
97             CAST(P\&.birthdate AS DATE) patientBirthdate,
98         M\&.uid mediaUID, 
99             F\&.uid, F\&.name, F\&.extension, 
100             CONVERT(VARCHAR, CAST(F\&.datetime AS DATETIME), 120) AS datetime,
101             H\&.status
102     FROM 
103         Hospital\&.patient P, Inspect\&.media M, 
104         Inspect\&.nonDicomFile F, v_nonDicomFileStatus H
105     WHERE 
106         P\&.id = M\&.patientID AND M\&.uid = F\&.mediaUID AND F\&.uid = H\&.uid
107 GO
108 
109 CREATE PROCEDURE goCandidateInspectList
110 AS
111     DECLARE @xml XML =
112     (
113         SELECT *
114         FROM
115         (
116             SELECT N'candidate' service
117         ) inspect
118         FOR XML AUTO
119     )
120     DECLARE @studyList XML =
121     (
122         SELECT study\&.*, series\&.*, image\&.*
123         FROM
124             v_candidateStudy study 
125                 LEFT OUTER JOIN Inspect\&.series series 
126                     ON study\&.uid = series\&.studyUID
127                 LEFT OUTER JOIN Inspect\&.image image
128                     ON series\&.uid = image\&.seriesUID
129         FOR XML AUTO, ROOT(N'studyList')
130     )
131     DECLARE @fileList XML =
132     (
133         SELECT * FROM v_candidateFile
134         FOR XML RAW(N'file'), ROOT(N'fileList')
135     )
136 
137     IF(@studyList IS NOT NULL)  SET @xml\&.modify('insert sql:variable("@studyList") into (/inspect)[1]')
138     IF(@fileList IS NOT NULL)   SET @xml\&.modify('insert sql:variable("@fileList") into (/inspect)[1]')
139 
140     SELECT @xml;
141 GO
.fi
.PP
.PP
\fBWarning:\fP
.RS 4
.RE
.PP
\fBEntityGroup\fP contains children entity elements as type of pointer\&. Because children entity objects are not serialized and referenced by pointer, its iteration and accessment is not fast\&. If it needs higher performance, then use \fBEntityArray\fP (static array for children entity) instead\&. 
.PP
\fB[Inherited]\fP
.RS 4

.RE
.PP
\fBEntity\fP is a class for standardization of expression method using on network I/O by XML\&. If \fBInvoke\fP is a standard message protocol of Samchon Framework which must be kept, \fBEntity\fP is a recommended semi-protocol of message for expressing a data class\&. Following the semi-protocol \fBEntity\fP is not imposed but encouraged\&. 
.PP
As we could get advantages from standardization of message for network I/O with \fBInvoke\fP, we can get additional advantage from standardizing expression method of data class with \fBEntity\fP\&. We do not need to know a part of network communication\&. Thus, with the \fBEntity\fP, we can only concentrate on entity's own logics and relationships between another entities\&. \fBEntity\fP does not need to how network communications are being done\&. 
.PP
 
.PP
\fBExample source\fP
.RS 4

.PP
.nf
1 #include <iostream>
2 
3 #include <samchon/protocol/Entity\&.hpp>
4 #include <samchon/protocol/IHTMLEntity\&.hpp>
5 #include <samchon/protocol/SharedEntityArray\&.hpp>
6 
7 #include <samchon/library/XML\&.hpp>
8 
9 #ifdef _WIN64
10 #   ifdef _DEBUG
11 #       pragma comment(lib, "x64/Debug/SamchonFramework\&.lib")
12 #   else
13 #       pragma comment(lib, "x64/Release/SamchonFramework\&.lib")
14 #   endif
15 #else
16 #   ifdef _DEBUG
17 #       pragma comment(lib, "Debug/SamchonFramework\&.lib")
18 #   else
19 #       pragma comment(lib, "Release/SamchonFramework\&.lib")
20 #   endif
21 #endif
22 
23 using namespace std;
24 using namespace samchon::library;
25 using namespace samchon::protocol;
26 
27 class Member 
28     : public Entity, public virtual IHTMLEntity
29 {
30 protected:
31     typedef Entity super;
32 
33     string id;
34     string name;
35     int age;
36     int grade;
37 
38 public:
39     /* ---------------------------------------------------------------------
40         CONSTRUCTORS
41     --------------------------------------------------------------------- */
42     Member() 
43         : super(), IHTMLEntity()
44     {
45     };
46     Member(const string &id, const string &name, int age, int grade)
47         : super(), IHTMLEntity()
48     {
49         this->id = id;
50         this->name = name;
51         this->age = age;
52         this->grade = grade;
53     };
54     virtual ~Member() = default;
55 
56     virtual void construct(shared_ptr<XML> xml) override
57     {
58         this->id = xml->getProperty("id");
59         this->name = xml->getProperty("name");
60         this->age = xml->getProperty<int>("age");
61         this->grade = xml->getProperty<int>("grade");
62     };
63 
64     /* ---------------------------------------------------------------------
65         GETTERSs
66     --------------------------------------------------------------------- */
67     virtual auto key() const -> std::string override
68     {
69         return this->id;
70     };
71 
72     /* ---------------------------------------------------------------------
73         XML EXPORTERS
74     --------------------------------------------------------------------- */
75     virtual auto TAG() const -> string override
76     {
77         return "member";
78     };
79     virtual auto toXML() const -> shared_ptr<XML>
80     {
81         shared_ptr<XML> &xml = super::toXML();
82         xml->setProperty("id", id);
83         xml->setProperty("name", name);
84         xml->setProperty("age", age);
85         xml->setProperty("grade", grade);
86         
87         return move(xml);
88     };
89     virtual auto toHTML() const -> string
90     {
91         return toTR(id, name, age, grade);
92     };
93 };
94 
95 class MemberArray
96     : public SharedEntityArray<Member>,
97     public virtual IHTMLEntity
98 {
99 protected:
100     typedef SharedEntityArray<Member> super;
101 
102     string application;
103     int department;
104     Member *chief;
105 
106 public:
107     /* ---------------------------------------------------------------------
108         CONSTRUCTORS
109     --------------------------------------------------------------------- */
110     MemberArray()
111         : super(), IHTMLEntity()
112     {
113         this->chief = nullptr;
114     };
115     virtual ~MemberArray() = default;
116 
117     // You don't need to consider children(Member) objects
118     // Just concentrate on constructing MemberArray's own member variables
119     virtual void construct(shared_ptr<XML> xml) override
120     {
121         super::construct(xml);
122 
123         this->application = xml->getProperty("application");
124         this->department = xml->getProperty<int>("department");
125 
126         if(xml->hasProperty("chief") == true && this->has( xml->getProperty("chief") ) == true)
127             this->chief = this->get( xml->getProperty("cheif") )\&.get();
128     };
129 
130 protected:
131     //FACTORY METHOD FOR MEMBER
132     virtual auto createChild(shared_ptr<XML> = nullptr) -> Member* override
133     {
134         return new Member();
135     };
136 
137     /* ---------------------------------------------------------------------
138         XML EXPORTERS
139     --------------------------------------------------------------------- */
140 public:
141     virtual auto TAG() const -> string override
142     {
143         return "memberArray";
144     };
145     virtual auto CHILD_TAG() const -> string override
146     {
147         return "member";
148     };
149 
150     // You don't need to consider children(Member) objects
151     // Just concentrate on expressing MemberArray's own member variables
152     virtual auto toXML() const -> shared_ptr<XML>
153     {
154         shared_ptr<XML> &xml = super::toXML();
155         xml->setProperty("application", application);
156         xml->setProperty("department", department);
157         
158         if(chief != nullptr)
159             xml->setProperty("cheif", chief->key());
160 
161         return move(xml);
162     };
163     virtual auto toHTML() const -> string
164     {
165         string html = "<table>\n";
166         html += toTH("ID", "Name", "Age", "Grade") + "\n";
167 
168         for (size_t i = 0; i < 2; i++)
169             html += at(i)->toHTML() + "\n";
170 
171         html += "</table>";
172         return move(html);
173     };
174 };
175 
176 void main()
177 {
178     string str = string("") +
179         "<memberArray application='framework' department='7' cheif='samchon'>\n" +
180         "   <member id='samchon' name='Jeongho Nam' age='27' grade='5' />" +
181         "   <member id='submaster' name='No Name' age='100' grade='4' />" +
182         "   <member id='john' name='John Doe' age='33' grade='2' />" +
183         "   <member id='bad_man' name='Bad Man' age='44' grade='-1' />" +
184         "   <member id='guest' name='Guest' age='0' grade='0' />" +
185         "</memberArray>";
186     shared_ptr<XML> xml(new XML(str));
187 
188     MemberArray memberArray;
189     memberArray\&.construct(xml);
190 
191     memberArray\&.emplace_back(new Member("freshman", "A fresh man", 20, 2));
192     memberArray\&.emplace_back(new Member("senior", "A senior", 70, 2));
193 
194     cout << memberArray\&.toXML()->toString() << endl << endl;
195     cout << memberArray\&.toHTML() << endl;
196     system("pause");
197 }

.fi
.PP
.RE
.PP
.SS "Result of the example "
.PP
 
.PP
\fBNote:\fP
.RS 4
.RE
.PP
I say repeatedly\&. Expression method of \fBEntity\fP is recommended, but not imposed\&. It's a semi protocol for network I/O but not a essential protocol must be kept\&. The expression method of \fBEntity\fP, using on network I/O, is expressed by XML string\&. 
.PP
If your own network system has a critical performance issue on communication data class, it would be better to using binary communication (with \fBByteArray\fP or boost::serialization)\&. Don't worry about the problem! \fBInvoke\fP also provides methods for binary data (\fBByteArray\fP)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBprotocol\fP 
.RE
.PP
\fBAuthor:\fP
.RS 4
Jeongho Nam 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "virtual void construct (std::shared_ptr< \fBlibrary::XML\fP > xml)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Construct data of the \fBEntity\fP from an XML object\&. Constructs the \fBEntityGroup\fP's own member variables only from the input XML object\&. 
.PP
Do not consider about constructing children \fBEntity\fP objects' data in \fBEntityGroup::construct()\fP\&. Those children \fBEntity\fP objects' data will constructed by their own \fBconstruct()\fP method\&. Even insertion of XML objects representing children are done by abstract method of \fBEntityGroup::toXML()\fP\&. 
.PP
Constructs only data of \fBEntityGroup\fP's own\&. 
.PP
\fB[Inherited]\fP
.RS 4
Construct data of the \fBEntity\fP from an XML object\&. 
.RE
.PP
Overrides the \fBconstruct()\fP method and fetch data of member variables from the XML\&. 
.PP
By recommended guidance, data representing member variables are contained in properties of the put XML object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxml\fP An xml used to construct data of entity 
.RE
.PP

.PP
Implements \fBEntity\fP\&.
.PP
Reimplemented in \fBDistributedSystem\fP, \fBNTCriteria\fP, \fBExternalSystem\fP, \fBParallelSystem\fP, \fBInvoke\fP, \fBDistributedSystemArray\fP, \fBDistributedSystemArrayMediator\fP, \fBParallelSystemArrayMediator\fP, \fBNTParameter\fP, \fBExternalClientArray\fP, \fBExternalServer\fP, \fBDistributedClientArrayMediator\fP, \fBParallelClientArrayMediator\fP, \fBDistributedClientArray\fP, \fBParallelServer\fP, and \fBDistributedServer\fP\&.
.SS "virtual auto createChild (std::shared_ptr< \fBlibrary::XML\fP >) \->  entity_type *\fC [protected]\fP, \fC [pure virtual]\fP"

.PP
Factory method of a child \fBEntity\fP\&. \fBEntityGroup::createChild()\fP is a factory method creating a new child \fBEntity\fP which is belonged to the \fBEntityGroup\fP\&. This method is called by \fBEntityGroup::construct()\fP\&. The children construction methods \fBEntity::construct()\fP will be called by abstract method of the \fBEntityGroup::construct()\fP\&. 
.PP
\fBReturns:\fP
.RS 4
A new child \fBEntity\fP belongs to \fBEntityGroup\fP\&. 
.RE
.PP

.PP
Implemented in \fBNTCriteria\fP, \fBInvoke\fP, \fBNTParameter\fP, \fBNTParameterArray\fP, \fBDSInvokeHistoryList\fP, \fBPRInvokeHistoryArray\fP, and \fBInvokeHistoryArray\fP\&.
.SS "auto has (const std::string & key) const \-> bool
			\fC [inline]\fP"

.PP
Indicates whether a container has an object having the specified identifier\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP An identifier of an \fBEntity\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
If there's the object then true, otherwise false 
.RE
.PP

.SS "auto get (const std::string & key) \-> value_type&
			\fC [inline]\fP"

.PP
Access the element by specified identifier(key)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP the identifier of the element wants to access 
.RE
.PP
\fBReturns:\fP
.RS 4
The element having the key, or throw exception if there is none\&. 
.RE
.PP

.SS "auto get (const std::string & key) const \-> const value_type&
			\fC [inline]\fP"

.PP
Access the const element by specified identifier(key)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP the identifier of the element wants to access 
.RE
.PP
\fBReturns:\fP
.RS 4
The const element having the key, or throw exception if there is none\&. 
.RE
.PP

.SS "virtual auto toXML () const \-> std::shared_ptr<\fBlibrary::XML\fP>
			\fC [inline]\fP, \fC [virtual]\fP"

.PP
Get an XML object represents the \fBEntityGroup\fP\&. Archives the \fBEntityGroup\fP's own member variables only to the returned XML object\&. 
.PP
Do not consider about archiving children \fBEntity\fP objects' data in \fBEntityGroup::toXML()\fP\&. Those children \fBEntity\fP objects will converted to XML object by their own \fBtoXML()\fP method\&. The insertion of XML objects representing children are done by abstract method of \fBEntityGroup::toXML()\fP\&. 
.PP
Archives only data of \fBEntityGroup\fP's own\&. 
.PP
\fB[Inherited]\fP
.RS 4
Get an XML object represents the \fBEntity\fP\&. 
.RE
.PP
Returns an XML object that can represents the \fBEntity\fP containing member variables into properties\&. 
.PP
A member variable (not object, but atomic value like number, string or date) is categorized as a property within the framework of entity side\&. Thus, when overriding a \fBtoXML()\fP method and archiving member variables to an XML object to return, puts each variable to be a property belongs to only an XML object\&. 
.PP
Don't archive the member variable of atomic value to XML::value causing enormouse creation of XML objects to number of member variables\&. An \fBEntity\fP must be represented by only an XML instance (tag)\&. 
.PP
Standard Usage  Non-standard usage abusing value   <memberList>
.br
      <member id='jhnam88' name='Jeongho+Nam' birthdate='1988-03-11' />
.br
      <member id='master' name='Administartor' birthdate='2011-07-28' />
.br
 </memberList>  <member>
.br
      <id>jhnam88</id>
.br
      <name>Jeongho+Nam</name>
.br
      <birthdate>1988-03-11</birthdate>
.br
 </member>   
.PP
\fBReturns:\fP
.RS 4
An XML object representing the \fBEntity\fP\&. 
.RE
.PP

.PP
Reimplemented from \fBEntity\fP\&.
.PP
Reimplemented in \fBInvoke\fP, \fBDistributedSystem\fP, \fBNTCriteria\fP, \fBExternalSystem\fP, \fBDistributedSystemArray\fP, \fBParallelSystem\fP, \fBNTParameter\fP, \fBDistributedSystemArrayMediator\fP, \fBParallelSystemArrayMediator\fP, \fBExternalClientArray\fP, \fBExternalServer\fP, \fBFTFolder\fP, \fBDistributedClientArrayMediator\fP, \fBParallelClientArrayMediator\fP, \fBDistributedClientArray\fP, \fBParallelServer\fP, and \fBDistributedServer\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Samchon Framework for CPP from the source code\&.
