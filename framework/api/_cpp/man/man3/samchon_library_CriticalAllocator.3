.TH "CriticalAllocator< _Ty >" 3 "Mon Oct 26 2015" "Version 1.0.0" "Samchon Framework for CPP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CriticalAllocator< _Ty > \- An allocator ensuring concurrency\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <CriticalAllocator\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "auto \fBgetMutex\fP () \-> \fBRWMutex\fP &"
.br
.RI "\fIGet rw_mutex\&. \fP"
.ti -1c
.RI "template<class _U , class\&.\&.\&. _Args> void \fBconstruct\fP (_U *ptr, _Args &&\&.\&.\&.args)"
.br
.RI "\fILock when constructed\&.
.br
 [Inherited] Construct an object\&.
.br
\&. \fP"
.ti -1c
.RI "template<class _U > void \fBdestroy\fP (_U *ptr)"
.br
.RI "\fILock when destroyed
.br
 [Inherited] Destory an object\&. \fP"
.ti -1c
.RI "auto \fBallocate\fP (size_type n, std::allocator< void >::const_pointer hint=NULL) \-> pointer"
.br
.RI "\fILock when allocated
.br
 [Inherited] Allocate block of storage\&. \fP"
.ti -1c
.RI "void \fBdeallocate\fP (pointer ptr, size_type size)"
.br
.RI "\fILock when deallocated
.br
 [Inherited] Release block of storage\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBRWMutex\fP \fBmtx\fP"
.br
.RI "\fIA rw_mutex for handling concurrency\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class _Ty>class samchon::library::CriticalAllocator< _Ty >"
An allocator ensuring concurrency\&. 

\fBCriticalAllocator\fP is a std::allocator ensuring concurrency\&. 
.PP
\fBCriticalAllocator\fP keeps safety in multi-threading environment automatically\&. But it ensures only safety\&. If a logic needs a mutual exclusion not only level of the container, it'd better to avoid using the \fBCriticalAllocator\fP and use \fBRWMutex\fP by yourself\&. 
.PP
\fB[Inherited]]\fP
.RS 4

.RE
.PP
Allocators are classes that define memory models to be used by some parts of the Standard Library, and most specifically, by STL containers\&. 
.PP
This section describes the default allocator template allocator (lowercase)\&. This is the allocator that all standard containers will use if their last (and optional) template parameter is not specified, and is the only predefined allocator in the standard library\&. </p<
.PP
Other allocators may be defined\&. Any class Alloc for which allocator_traits<Alloc> produces a valid instantiation with the appropriate members defined can be used as an allocator on standard containers (Alloc may or may not implement the functionality through member functions)\&. </p<
.PP
Except for its destructor, no member of the standard default allocator class template shall introduce data races\&. Calls to member functions that allocate or deallocate storage shall occur in a single total order, and each such deallocation shall happen before the next allocation (if any) in this order\&. 
.PP
Technically, a memory model described by allocators might be specialized for each type of object to be allocated and even may store local data for each container they work with\&. Although this does not happen with the default allocator\&. 
.PP
Referenced comments of std::allocator 
.PP
.PD 0
.IP "\(bu" 2
http://www.cplusplus.com/reference/memory/allocator/
.PP
 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Ty\fP Type of the elements allocated by the object (aliased as member type value_type)\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBsamchon::library\fP 
.RE
.PP
\fBAuthor:\fP
.RS 4
Jeongho Nam 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void construct (_U * ptr, _Args &&\&.\&.\&. args)\fC [inline]\fP"

.PP
Lock when constructed\&.
.br
 [Inherited] Construct an object\&.
.br
\&. 
.PP
\fB\fP
.RS 4
Locks a mutex for concurrency when an elmented is constructed\&.
.RE
.PP
\fB[Inherited] \fP
.RS 4

.RE
.PP
Constructs an element object on the location pointed by p\&. 
.PP
Notice that this does not allocate space for the element\&. It should already be available at p (see member allocate to allocate space)\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_U\fP 
.br
\fI_Args\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to a location with enough storage space to contain an element of type _U\&. 
.br
\fIargs\fP Arguments forwarded to the constructor\&.
.br
 Args is a list of zero or more types\&. 
.RE
.PP

.SS "void destroy (_U * ptr)\fC [inline]\fP"

.PP
Lock when destroyed
.br
 [Inherited] Destory an object\&. 
.PP
\fB\fP
.RS 4
Locks a mutex for concurrency when an child is destroyed
.RE
.PP
\fB[Inherited] \fP
.RS 4

.RE
.PP
Destroys in-place the object pointed by p\&. 
.PP
Notice that this does not deallocate the storage for the element (see member deallocate to release storage space)\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_U\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to the object to be destroyed\&. 
.RE
.PP

.SS "auto allocate (size_type n, std::allocator< void >::const_pointer hint = \fCNULL\fP) \-> pointer
			\fC [inline]\fP"

.PP
Lock when allocated
.br
 [Inherited] Allocate block of storage\&. Locks a mutex for concurrency when children elements are deallocated\&. 
.PP
\fB[Inherited]\fP
.RS 4

.RE
.PP
Attempts to allocate a block of storage with a size large enough to contain n elements of member type value_type (an alias of the allocator's template parameter), and returns a pointer to the first element\&. 
.PP
The storage is aligned appropriately for objects of type value_type, but they are not constructed\&. 
.PP
In the standard default allocator, the block of storage is allocated using ::operator new one or more times, and throws bad_alloc if it cannot allocate the total amount of storage requested\&. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Number of elements (each of size sizeof(value_type)) to be allocated\&.
.br
 The member type size_type is an alias of size_t (in the standard default allocator) size_t is an unsigned integral type\&. 
.br
\fIhint\fP Either 0 or a value previously obtained by another call to allocate and not yet freed with deallocate\&. When it is not 0, this value may be used as a hint to improve performance by allocating the new block near the one specified\&. The address of an adjacent element is often a good choice\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
\fBA pointer to the initial element in the block of storage\&.\fP
.RS 4

.RE
.PP
\fBpointer and const_pointer are member types (defined as aliases of T* and const T* respectively in std::allocator)\&.\fP
.RS 4

.RE
.PP
\fBThe standard default allocator throws bad_alloc if it cannot allocate the requested amount of storage\&.\fP
.RS 4

.RE
.PP

.SS "void deallocate (pointer ptr, size_type size)\fC [inline]\fP"

.PP
Lock when deallocated
.br
 [Inherited] Release block of storage\&. Locks a mutex for concurrency when children elements are deallocated\&. 
.PP
\fB[Inherited]\fP
.RS 4

.RE
.PP
Releases a block of storage previously allocated with member allocate and not yet released\&. 
.PP
The elements in the array are not destroyed by a call to this member function\&. 
.PP
In the default allocator, the block of storage is at some point deallocated using ::operator delete (either during the function call, or later)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to a block of storage previously allocated with allocator::allocate\&.
.br
 pointer is a member type (defined as an alias of T* in std::allocator<_Ty>)\&. 
.br
\fIsize\fP Number of elements allocated on the call to allocator::allocate for this block of storage\&. The member type size_type is an alias of size_t (in the standard default allocator)\&. size_t is an unsigned integral type\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Samchon Framework for CPP from the source code\&.
