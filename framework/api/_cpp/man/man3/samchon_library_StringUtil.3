.TH "StringUtil" 3 "Mon Oct 26 2015" "Version 1.0.0" "Samchon Framework for CPP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StringUtil \- Utility class for string\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <StringUtil\&.hpp>\fP
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename _Ty , typename\&.\&.\&. _Args> static auto \fBsubstitute\fP (const std::string &format, const _Ty &val, const _Args &\&.\&.\&.args) \-> std::string"
.br
.RI "\fISubstitutes "{n}" tokens within the specified string with the respective arguments passed in\&. \fP"
.ti -1c
.RI "template<typename _Ty , typename\&.\&.\&. _Args> static auto \fBsubstituteSQL\fP (const std::string &format, const _Ty &value, const _Args &\&.\&.\&.args) \-> std::string"
.br
.RI "\fISubstitutes "{n}" tokens within the specified sql-string with the respective arguments passed in\&.
.br
\&. \fP"
.ti -1c
.RI "static auto \fBisNumeric\fP (const std::string &str) \-> bool"
.br
.RI "\fIReturns wheter the std::string represents Number or not
.br
\&. \fP"
.ti -1c
.RI "static auto \fBtoNumber\fP (const std::string &str) \-> double"
.br
.RI "\fINumber std::string to Number having ',' symbols\&. \fP"
.ti -1c
.RI "static auto \fBnumberFormat\fP (double val, int precision=2) \-> std::string"
.br
.ti -1c
.RI "static auto \fBpercentFormat\fP (double val, int precision=2) \-> std::string"
.br
.RI "\fIReturns a percentage string converted from the number rounded off from specified precision with "," symbols
.br
     ex) percentFormat(11\&.3391, 1) => 1,133\&.9%\&. \fP"
.ti -1c
.RI "static auto \fBcolorNumberFormat\fP (double value, int precision=2, double delimiter=0\&.0) \-> std::string"
.br
.RI "\fIReturns a string converted from the number rounded off from specified precision with "," symbols and color tag
.br
     ex) numberFormat(17151\&.339, 2) => <font color='red'>17,151\&.34</font> \fP"
.ti -1c
.RI "static auto \fBcolorPercentFormat\fP (double value, int precision=2, double delimiter=0\&.0) \-> std::string"
.br
.RI "\fIReturns a percentage string converted from the number rounded off from specified precision with "," symbols
.br
     ex) percentFormat(11\&.3391, 1) => 1,133\&.9%\&. \fP"
.ti -1c
.RI "static auto \fBtrim\fP (const std::string &val, const std::vector< std::string > &delims) \-> std::string"
.br
.RI "\fIRemoves all designated characters from the beginning and end of the specified string\&. \fP"
.ti -1c
.RI "static auto \fBltrim\fP (const std::string &val, const std::vector< std::string > &delims) \-> std::string"
.br
.RI "\fIRemoves all designated characters from the beginning of the specified string\&. \fP"
.ti -1c
.RI "static auto \fBrtrim\fP (const std::string &val, const std::vector< std::string > &delims) \-> std::string"
.br
.RI "\fIRemoves all designated characters from the end of the specified string\&. \fP"
.ti -1c
.RI "static auto \fBfinds\fP (const std::string &str, const std::vector< std::string > &delims, size_t startIndex=0) \-> \fBIndexPair\fP< std::string >"
.br
.RI "\fIFinds first occurence in string\&. \fP"
.ti -1c
.RI "static auto \fBrfinds\fP (const std::string &str, const std::vector< std::string > &delims, size_t endIndex=SIZE_MAX) \-> \fBIndexPair\fP< std::string >"
.br
.RI "\fIFinds last occurence in string\&. \fP"
.ti -1c
.RI "static auto \fBsubstring\fP (const std::string &str, size_t startIndex, size_t endIndex=SIZE_MAX) \-> std::string"
.br
.RI "\fIGenerates a substring\&. \fP"
.ti -1c
.RI "static auto \fBbetween\fP (const std::string &str, const std::string &start='', const std::string &end='') \-> std::string"
.br
.RI "\fIGenerates a substring\&. \fP"
.ti -1c
.RI "static auto \fBaddTab\fP (const std::string &str, size_t n=1) \-> std::string"
.br
.RI "\fIAdds tab() character to first position of each line\&. \fP"
.ti -1c
.RI "static auto \fBsplit\fP (const std::string &str, const std::string &delim) \-> std::vector< std::string >"
.br
.RI "\fIGenerates substrings\&. \fP"
.ti -1c
.RI "static auto \fBbetweens\fP (const std::string &str, const std::string &start='', const std::string &end='') \-> std::vector< std::string >"
.br
.RI "\fIGenerates substrings\&. \fP"
.ti -1c
.RI "static auto \fBtoLowerCase\fP (const std::string &str) \-> std::string"
.br
.RI "\fIReturns a string that all uppercase characters are converted to lowercase
.br
\&. \fP"
.ti -1c
.RI "static auto \fBtoUpperCase\fP (const std::string &str) \-> std::string"
.br
.ti -1c
.RI "static auto \fBreplaceAll\fP (const std::string &str, const std::string &before, const std::string &after) \-> std::string"
.br
.RI "\fIReturns a string specified word is replaced\&. \fP"
.ti -1c
.RI "static auto \fBreplaceAll\fP (const std::string &str, const std::vector< std::pair< std::string, std::string >> &pairs) \-> std::string"
.br
.RI "\fIReturns a string specified words are replaced\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Utility class for string\&. 

\fBStringUtil\fP is an utility class providing lots of static methods for std::string\&. 
.PP
There are two methods to strength std::string to have addictional uility methods like trim and split\&. The way of first is to make std::string class inheriting from std::string\&. The second is to make \fBStringUtil\fP class having static methods\&. 
.PP
But those methods have problems\&. std::string class violates standard and \fBStringUtil\fP class violates principle of Object-Oriented Design\&. For the present, I've made the \fBStringUtil\fP class, but if you have a good opinion about the issue, please write your opinion on my github\&. 
.PP
 
.PP
\fBSee also:\fP
.RS 4
library::WeakString 
.PP
\fBsamchon::library\fP 
.RE
.PP
\fBAuthor:\fP
.RS 4
Jeongho Nam 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "static auto substitute (const std::string & format, const _Ty & val, const _Args &\&.\&.\&. args) \-> std::string
			\fC [inline]\fP, \fC [static]\fP"

.PP
Substitutes "{n}" tokens within the specified string with the respective arguments passed in\&. 
.PP
\fBParameters:\fP
.RS 4
\fIformat\fP The string to make substitutions in\&.
.br
 This string can contain special tokens of the form {n}, where n is a zero based index, that will be replaced with the additional parameters found at that index if specified 
.br
\fIval\fP Target value to substitute the minimum {n} tokens 
.br
\fIargs\fP Additional parameters that can be substituted in the str parameter at each {n} location, where n is an integer (zero based) index value into the varadics of values specified\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
New string with all of the {n} tokens replaced with the respective arguments specified\&. 
.RE
.PP

.SS "static auto substituteSQL (const std::string & format, const _Ty & value, const _Args &\&.\&.\&. args) \-> std::string
			\fC [inline]\fP, \fC [static]\fP"

.PP
Substitutes "{n}" tokens within the specified sql-string with the respective arguments passed in\&.
.br
\&. 
.PP
\fBWarning:\fP
.RS 4
substituteSQL creates the dynamic sql-statement\&.
.br
 Not recommended when the dynamic sql-statement is not only for procedure\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIformat\fP The string to make substitutions in\&.
.br
 This string can contain special tokens of the form {n}, where n is a zero based index, that will be replaced with the additional parameters found at that index if specified 
.br
\fIval\fP Target value to substitute the minimum {n} tokens 
.br
\fIargs\fP Additional parameters that can be substituted in the str parameter at each {n} location, where n is an integer (zero based) index value into the varadics of values specified\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
New sql-string with all of the {n} tokens replaced with the respective arguments specified\&. 
.RE
.PP

.SS "auto isNumeric (const std::string & str) \-> bool\fC [static]\fP"

.PP
Returns wheter the std::string represents Number or not
.br
\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target std::string to check 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether the std::string can be converted to Number or not 
.RE
.PP

.SS "auto toNumber (const std::string & str) \-> double\fC [static]\fP"

.PP
Number std::string to Number having ',' symbols\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target std::string you want to convert to Number 
.RE
.PP
\fBReturns:\fP
.RS 4
Number from std::string 
.RE
.PP

.SS "auto numberFormat (double val, int precision = \fC2\fP) \-> std::string\fC [static]\fP"
Returns a string converted from the number rounded off from specified precision with "," symbols      ex) numberFormat(17151\&.339, 2) => 17,151\&.34
.PP
\fBParameters:\fP
.RS 4
\fIval\fP A number wants to convert to string 
.br
\fIprecision\fP Target precision of roundoff 
.RE
.PP
\fBReturns:\fP
.RS 4
A string representing the number with roundoff and "," symbols 
.RE
.PP

.SS "auto percentFormat (double val, int precision = \fC2\fP) \-> std::string\fC [static]\fP"

.PP
Returns a percentage string converted from the number rounded off from specified precision with "," symbols
.br
     ex) percentFormat(11\&.3391, 1) => 1,133\&.9%\&. 
.PP
\fBWarning:\fP
.RS 4
Do not multiply by 100 to the value representing percent 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIval\fP A number wants to convert to percentage string 
.br
\fIprecision\fP Target precision of roundoff 
.RE
.PP

.SS "auto colorNumberFormat (double value, int precision = \fC2\fP, double delimiter = \fC0\&.0\fP) \-> std::string\fC [static]\fP"

.PP
Returns a string converted from the number rounded off from specified precision with "," symbols and color tag
.br
     ex) numberFormat(17151\&.339, 2) => <font color='red'>17,151\&.34</font> Which color would be chosen 
.PD 0

.IP "\(bu" 2
Number is positive, color is RED 
.IP "\(bu" 2
Number is zero (0), color is BLACK 
.IP "\(bu" 2
Number is negative, color is BLUE
.PP
\fBParameters:\fP
.RS 4
\fIval\fP A number wants to convert to colored string 
.br
\fIprecision\fP Target precision of roundoff 
.RE
.PP
\fBReturns:\fP
.RS 4
A colored string representing the number with roundoff and "," symbols 
.RE
.PP

.SS "auto colorPercentFormat (double value, int precision = \fC2\fP, double delimiter = \fC0\&.0\fP) \-> std::string\fC [static]\fP"

.PP
Returns a percentage string converted from the number rounded off from specified precision with "," symbols
.br
     ex) percentFormat(11\&.3391, 1) => 1,133\&.9%\&. 
.PP
\fBWarning:\fP
.RS 4
Do not multiply by 100 to the value representing percent 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIval\fP A number wants to convert to percentage string 
.br
\fIprecision\fP Target precision of roundoff 
.RE
.PP

.SS "static auto trim (const std::string & val, const std::vector< std::string > & delims) \->  std::string\fC [static]\fP"

.PP
Removes all designated characters from the beginning and end of the specified string\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP The string should be trimmed 
.br
\fIdelims\fP Designated character(s) 
.RE
.PP
\fBReturns:\fP
.RS 4
Updated string where designated characters was removed from the beginning and end 
.RE
.PP

.SS "static auto ltrim (const std::string & val, const std::vector< std::string > & delims) \->  std::string\fC [static]\fP"

.PP
Removes all designated characters from the beginning of the specified string\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP The string should be trimmed 
.br
\fIdelims\fP Designated character(s) 
.RE
.PP
\fBReturns:\fP
.RS 4
Updated string where designated characters was removed from the beginning 
.RE
.PP

.SS "static auto rtrim (const std::string & val, const std::vector< std::string > & delims) \->  std::string\fC [static]\fP"

.PP
Removes all designated characters from the end of the specified string\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP The string should be trimmed 
.br
\fIdelims\fP Designated character(s) 
.RE
.PP
\fBReturns:\fP
.RS 4
Updated string where designated characters was removed from the end 
.RE
.PP

.SS "auto finds (const std::string & str, const std::vector< std::string > & delims, size_t startIndex = \fC0\fP) \-> \fBIndexPair\fP<std::string>\fC [static]\fP"

.PP
Finds first occurence in string\&. Finds first occurence position of each delim in the string after startIndex and returns the minimum position of them
.br

.br
If startIndex is not specified, then starts from 0\&.
.br
If failed to find any substring, returns -1 (std::string::npos)
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target string to find 
.br
\fIdelims\fP The substrings of target(str) which to find 
.br
\fIstartIndex\fP Specified starting index of find\&. Default is 0 
.RE
.PP
\fBReturns:\fP
.RS 4
pair<size_t := position, string := matched substring> 
.RE
.PP

.SS "auto rfinds (const std::string & str, const std::vector< std::string > & delims, size_t endIndex = \fCSIZE_MAX\fP) \-> \fBIndexPair\fP<std::string>\fC [static]\fP"

.PP
Finds last occurence in string\&. Finds last occurence position of each delim in the string before endIndex and returns the maximum position of them
.br

.br
If index is not specified, then starts str\&.size() - 1
.br
If failed to find any substring, returns -1 (std::string::npos)
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target string to find 
.br
\fIdelims\fP The substrings of target(str) which to find 
.br
\fIendIndex\fP Specified starting index of find\&. Default is str\&.size() - 1 
.RE
.PP
\fBReturns:\fP
.RS 4
pair<size_t := position, string := matched substring> 
.RE
.PP

.SS "auto substring (const std::string & str, size_t startIndex, size_t endIndex = \fCSIZE_MAX\fP) \-> std::string\fC [static]\fP"

.PP
Generates a substring\&. Extracts a string consisting of the character specified by startIndex and all characters up to endIndex - 1 If endIndex is not specified, string::size() will be used instead\&.
.br
If endIndex is greater than startIndex, then those will be swapped
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target string to be applied substring 
.br
\fIstartIndex\fP Index of the first character\&.
.br
 If startIndex is greater than endIndex, those will be swapped 
.br
\fIendIndex\fP Index of the last character - 1\&.
.br
 If not specified, then string::size() will be used instead 
.RE
.PP
\fBReturns:\fP
.RS 4
Extracted string by specified index(es) 
.RE
.PP

.SS "auto between (const std::string & str, const std::string & start = \fC''\fP, const std::string & end = \fC''\fP) \-> std::string\fC [static]\fP"

.PP
Generates a substring\&. Extracts a substring consisting of the characters from specified start to end It's same with str\&.substring( ? = (str\&.find(start) + start\&.size()), str\&.find(end, ?) )
.br
     ex) between('ABCD[EFGH]IJK', '[', ']') => 'EFGH'
.br

.br
If start is not specified, extracts from begin of the string to end
.br
If end is not specified, extracts from start to end of the string
.br
If start and end are all omitted, returns str, itself\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target string to be applied between 
.br
\fIstart\fP A string for separating substring at the front 
.br
\fIend\fP A string for separating substring at the end 
.RE
.PP
\fBReturns:\fP
.RS 4
substring by specified terms 
.RE
.PP

.SS "auto addTab (const std::string & str, size_t n = \fC1\fP) \-> std::string\fC [static]\fP"

.PP
Adds tab() character to first position of each line\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target str to add tabs 
.br
\fIn\fP The size of tab to be added for each line 
.RE
.PP
\fBReturns:\fP
.RS 4
A string added multiple tabs 
.RE
.PP

.SS "auto split (const std::string & str, const std::string & delim) \-> std::vector<std::string>\fC [static]\fP"

.PP
Generates substrings\&. Splits a string into an array of substrings by dividing the specified delimiter
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target string to split 
.br
\fIdelim\fP The pattern that specifies where to split this string 
.RE
.PP
\fBReturns:\fP
.RS 4
An array of substrings 
.RE
.PP

.SS "auto betweens (const std::string & str, const std::string & start = \fC''\fP, const std::string & end = \fC''\fP) \-> std::vector<std::string>\fC [static]\fP"

.PP
Generates substrings\&. Splits a string into an array of substrings dividing by specified delimeters of start and end
.br
It's the array of substrings adjusted the between
.br

.br
If startStr is omitted, it's same with the split by endStr not having last item
.br
If endStr is omitted, it's same with the split by startStr not having first item
.br
If startStr and endStar are all omitted, returns {str}
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target string to split by between 
.br
\fIstart\fP A string for separating substring at the front
.br
 If omitted, it's same with split(end) not having last item 
.br
\fIend\fP A string for separating substring at the end
.br
 If omitted, it's same with split(start) not having first item 
.RE
.PP
\fBReturns:\fP
.RS 4
An array of substrings 
.RE
.PP

.SS "auto toLowerCase (const std::string & str) \-> std::string\fC [static]\fP"

.PP
Returns a string that all uppercase characters are converted to lowercase
.br
\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target string to convert uppercase to lowercase 
.RE
.PP
\fBReturns:\fP
.RS 4
A string converted to lowercase 
.RE
.PP

.SS "auto toUpperCase (const std::string & str) \-> std::string\fC [static]\fP"
Returns a string all lowercase characters are converted to uppercase
.br
 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target string to convert lowercase to uppercase 
.RE
.PP
\fBReturns:\fP
.RS 4
A string converted to uppercase 
.RE
.PP

.SS "static auto replaceAll (const std::string & str, const std::string & before, const std::string & after) \->  std::string\fC [static]\fP"

.PP
Returns a string specified word is replaced\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target string to replace 
.br
\fIbefore\fP Specific word you want to be replaced 
.br
\fIafter\fP Specific word you want to replace 
.RE
.PP
\fBReturns:\fP
.RS 4
A string specified word is replaced 
.RE
.PP

.SS "static auto replaceAll (const std::string & str, const std::vector< std::pair< std::string, std::string >> & pairs) \->  std::string\fC [static]\fP"

.PP
Returns a string specified words are replaced\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Target string to replace 
.br
\fIpairs\fP A specific word's pairs you want to replace and to be replaced 
.RE
.PP
\fBReturns:\fP
.RS 4
A string specified words are replaced 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Samchon Framework for CPP from the source code\&.
