.TH "SmartPointer< _Ty >" 3 "Mon Oct 26 2015" "Version 1.0.0" "Samchon Framework for CPP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SmartPointer< _Ty > \- Global shared pointer
.br
\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <SmartPointer\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSmartPointer\fP ()"
.br
.RI "\fIDefault Constructor\&. \fP"
.ti -1c
.RI "\fBSmartPointer\fP (const _Ty *\fBptr\fP)"
.br
.RI "\fIConstrct from pointer\&. \fP"
.ti -1c
.RI "\fBSmartPointer\fP (const \fBSmartPointer\fP &smartPointer)"
.br
.RI "\fICopy Constructor\&. \fP"
.ti -1c
.RI "\fBSmartPointer\fP (\fBSmartPointer\fP &&smartPointer)"
.br
.RI "\fIMove constructor\&. \fP"
.ti -1c
.RI "\fB~SmartPointer\fP ()"
.br
.RI "\fIDestroy \fBSmartPointer\fP\&. \fP"
.ti -1c
.RI "void \fBreset\fP (const _Ty *\fBptr\fP)"
.br
.RI "\fIReset pointer\&. \fP"
.ti -1c
.RI "auto \fBget\fP () const  \-> _Ty *"
.br
.RI "\fIGet pointer\&. \fP"
.ti -1c
.RI "auto \fBoperator\->\fP () const  \-> _Ty *"
.br
.RI "\fIDereference object membr\&. \fP"
.ti -1c
.RI "auto \fBoperator*\fP () const  \-> _Ty &"
.br
.RI "\fIDereference object\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "_Ty * \fBptr\fP"
.br
.RI "\fIA pointer managed by \fBSmartPointer\fP\&. \fP"
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static std::map< _Ty *, size_t > \fBuseCountMap\fP"
.br
.RI "\fI\fBMap\fP of use count of each pointer\&. \fP"
.ti -1c
.RI "static std::mutex \fBmtx\fP"
.br
.RI "\fIMutex assigned to useCountMap\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Ty>class samchon::SmartPointer< _Ty >"
Global shared pointer
.br
\&. 

\fBSmartPointer\fP is a global shared pointer based on map, map referencing\&. 
.PP
Manages the storage of a pointer, providing a limited garbage-collection facility, possibly sharing that management with other objects\&. 
.PP
Referenced comments of std::allocator\&. 
.PP
.PD 0
.IP "\(bu" 2
http://www.cplusplus.com/reference/memory/shared_ptr/
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIThe\fP type of managed object 
.RE
.PP
\fBAuthor:\fP
.RS 4
Jeongho Nam 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBSmartPointer\fP ()\fC [inline]\fP"

.PP
Default Constructor\&. The object is empty (owns no pointer, use count of zero) 
.SS "\fBSmartPointer\fP (const _Ty * ptr)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Constrct from pointer\&. The object owns ptr, setting the use count to add 1
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP The pointer to own 
.RE
.PP

.SS "\fBSmartPointer\fP (const \fBSmartPointer\fP< _Ty > & smartPointer)\fC [inline]\fP"

.PP
Copy Constructor\&. The object shares ownership of smartPointer's asset and increases the use count
.PP
\fBParameters:\fP
.RS 4
\fIsmartPointer\fP The object to copy 
.RE
.PP

.SS "\fBSmartPointer\fP (\fBSmartPointer\fP< _Ty > && smartPointer)\fC [inline]\fP"

.PP
Move constructor\&. The object acquires the content managed by smartPointer
.br
The ceding object becomes empty and there's no change on use count
.PP
\fBParameters:\fP
.RS 4
\fIsmartPointer\fP The object to move 
.RE
.PP

.SS "~\fBSmartPointer\fP ()\fC [inline]\fP"

.PP
Destroy \fBSmartPointer\fP\&. Destroys the object\&. But, before, it may produce the following side effects depending on the use_count of member
.PP
.PD 0
.IP "\(bu" 2
If use_count is greater than 1: The use count is decreased by 1\&. 
.IP "\(bu" 2
If use_count is 1 (i\&.e\&., the object is the unique owner of the managed pointer): the object pointed by its owned pointer is deleted\&. 
.IP "\(bu" 2
If use_count is zero (i\&.e\&., the object is empty), this destructor has no side effects\&. 
.PP

.SH "Member Function Documentation"
.PP 
.SS "void reset (const _Ty * ptr)\fC [inline]\fP"

.PP
Reset pointer\&. Reset pointer to manage and shrink use count of previous pointer\&. 
.PP
Additionally, a call to this function has the same side effects as if \fBSmartPointer\fP's destructor was called before its value changed (including the deletion of the managed object if this \fBSmartPointer\fP was unique)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIPointer\fP whose ownership is taken over by the object\&. Unlike std::shared_ptr, ptr being managed by another \fBSmartPointer\fP does not cause any problem 
.RE
.PP

.SS "auto get () const \-> _Ty*
		\fC [inline]\fP"

.PP
Get pointer\&. Returns the stored pointer\&. 
.PP
The stored pointer points to the object the shared_ptr object dereferences to, which is generally the same as its owned pointer\&. 
.PP
\fBReturns:\fP
.RS 4
The stored pointer 
.RE
.PP

.SS "auto operator\-> () const \-> _Ty*
		\fC [inline]\fP"

.PP
Dereference object membr\&. Returns a pointer to the object pointed by the stored pointer in order to access one of its members\&. This member function shall not be called if the stored pointer is a null pointer\&. 
.PP
It returns the same value as \fBget()\fP\&. 
.PP
\fBReturns:\fP
.RS 4
A pointer to be managed by \fBSmartPointer\fP 
.RE
.PP

.SS "auto operator* () const \-> _Ty&
		\fC [inline]\fP"

.PP
Dereference object\&. Returns a reference to the object pointerd by pointer\&. It is equivalent to: *get()
.PP
\fBReturns:\fP
.RS 4
A reference to the object pointed 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Samchon Framework for CPP from the source code\&.
