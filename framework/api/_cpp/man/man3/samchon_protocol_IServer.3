.TH "IServer" 3 "Mon Oct 26 2015" "Version 1.0.0" "Samchon Framework for CPP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IServer \- An interface of a physical server\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <IServer\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIServer\fP ()"
.br
.RI "\fIDefault Constructor\&. \fP"
.ti -1c
.RI "virtual void \fBopen\fP ()"
.br
.RI "\fIOpen the server\&. \fP"
.ti -1c
.RI "virtual void \fBclose\fP ()"
.br
.RI "\fIClose the server\&. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual auto \fBMY_IP\fP () const  \-> std::string"
.br
.RI "\fI(optional) Server's IP \fP"
.ti -1c
.RI "virtual auto \fBPORT\fP () const  \-> int=NULL"
.br
.RI "\fIPort number of the server\&. \fP"
.ti -1c
.RI "virtual void \fBaddClient\fP (Socket *)=0"
.br
.RI "\fIHandling connection of a physical client\&. \fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "Acceptor * \fBacceptor\fP"
.br
.RI "\fIAn acceptor for clients\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
An interface of a physical server\&. 

\fBIServer\fP provides methods for opening a server\&. 
.PP
\fBIServer\fP is one of the basic 3 + 1 components that can make any type of network system in Samchon Framework with \fBIProtocol\fP and \fBIClient\fP\&. Looking around classes in Samchon Framework, you can see all servers are implemented from the \fBIServer\fP\&. 
.PP
When a client connects to the server, the abstract method \fBIServer::addClient()\fP is called with a new thread\&. If you want to accept only a client at a time, use OneToOneServer instead\&. 
.PP
 
.PP
.SS "Example source"
.PP
A simple chat server running on console 
.PP
\fBexamples/console_chat_server/ChatServer\&.hpp\fP
.RS 4

.PP
.nf
1 #pragma once
2 #include <samchon/protocol/IServer\&.hpp>
3 #include <samchon/protocol/IProtocol\&.hpp>
4 
5 #include <set>
6 #include <samchon/library/RWMutex\&.hpp>
7 
8 namespace samchon
9 {
10     namespace example
11     {
21         namespace console_chat_server
22         {
23             class ChatClient;
24 
30             class ChatServer
31                 : public protocol::IServer,
32                 public protocol::IProtocol
33             {
34             private:
35                 typedef protocol::IServer super;
36 
40                 std::set<ChatClient*> clientSet;
41 
45                 library::RWMutex rwMutex;
46 
47             public:
51                 ChatServer();
52                 virtual ~ChatServer() = default;
53 
57                 void eraseClient(ChatClient *client);
58 
59             protected:
63                 virtual auto PORT() const -> int override
64                 {
65                     return 37749;
66                 };
67 
71                 virtual void addClient(protocol::Socket *socket) override;
72 
73             public:
80                 virtual void replyData(std::shared_ptr<protocol::Invoke>) override;
81 
88                 virtual void sendData(std::shared_ptr<protocol::Invoke>) override;
89             };
90         };
91     };
92 };

.fi
.PP
 
.RE
.PP
\fBexamples/console_chat_server/ChatServer\&.cpp\fP
.RS 4

.PP
.nf
1 #include <samchon/examples/console_chat_server/ChatServer\&.hpp>
2 #include <samchon/examples/console_chat_server/ChatClient\&.hpp>
3 
4 #include <thread>
5 #include <samchon/protocol/Invoke\&.hpp>
6 
7 using namespace std;
8 using namespace samchon::library;
9 using namespace samchon::protocol;
10 using namespace samchon::example::console_chat_server;
11 
12 ChatServer::ChatServer()
13     : super()
14 {
15 }
16 void ChatServer::addClient(Socket *socket)
17 {
18     ChatClient *client = new ChatClient(this, socket);
19 
20     UniqueWriteLock uk(rwMutex);
21     clientSet\&.insert(client);
22 
23     thread(&ChatClient::listen, client)\&.detach();
24 }
25 void ChatServer::eraseClient(ChatClient *client)
26 {
27     UniqueWriteLock uk(rwMutex);
28     clientSet\&.erase(client);
29 }
30 
31 void ChatServer::replyData(shared_ptr<Invoke> invoke)
32 {
33     sendData(invoke);
34 }
35 void ChatServer::sendData(shared_ptr<Invoke> invoke)
36 {
37     UniqueReadLock uk(rwMutex);
38 
39     for(auto it = clientSet\&.begin(); it != clientSet\&.end(); it++)
40         (*it)->sendData(invoke);
41 }

.fi
.PP
 
.RE
.PP
\fBexamples/console_chat_server/ChatClient\&.hpp\fP
.RS 4

.PP
.nf
1 #pragma once
2 #include <samchon/protocol/IClient\&.hpp>
3 
4 namespace samchon
5 {
6     namespace example
7     {
8         namespace console_chat_server
9         {
10             class ChatServer;
11 
21             class ChatClient
22                 : public protocol::IClient
23             {
24             private:
25                 typedef protocol::IClient super;
26 
30                 ChatServer *server;
31 
32             public:
39                 ChatClient(ChatServer*, protocol::Socket*);
40 
45                 virtual ~ChatClient();
46 
51                 virtual void replyData(std::shared_ptr<protocol::Invoke>) override;
52             };
53         };
54     };
55 };

.fi
.PP
 
.RE
.PP
\fBexamples/console_chat_server/ChatClient\&.cpp\fP
.RS 4

.PP
.nf
1 #include <samchon/examples/console_chat_server/ChatClient\&.hpp>
2 #include <samchon/examples/console_chat_server/ChatServer\&.hpp>
3 
4 #include <samchon/protocol/Invoke\&.hpp>
5 
6 using namespace std;
7 using namespace samchon::library;
8 using namespace samchon::protocol;
9 using namespace samchon::example::console_chat_server;
10 
11 ChatClient::ChatClient(ChatServer *server, Socket *socket)
12     : super()
13 {
14     this->server = server;
15     this->socket = socket;
16 }
17 ChatClient::~ChatClient()
18 {
19     server->eraseClient(this);
20 }
21 
22 void ChatClient::replyData(shared_ptr<Invoke> invoke)
23 {
24     server->replyData(invoke);
25 }

.fi
.PP
 
.RE
.PP
\fBexamples/console_chat_server/main\&.cpp\fP
.RS 4

.PP
.nf
1 #include <iostream>
2 #include <samchon/examples/console_chat_server/ChatServer\&.hpp>
3 
4 #ifdef _WIN64
5 #   ifdef _DEBUG
6 #       pragma comment(lib, "x64/Debug/SamchonFramework\&.lib")
7 #   else
8 #       pragma comment(lib, "x64/Release/SamchonFramework\&.lib")
9 #   endif
10 #else
11 #   ifdef _DEBUG
12 #       pragma comment(lib, "Debug/SamchonFramework\&.lib")
13 #   else
14 #       pragma comment(lib, "Release/SamchonFramework\&.lib")
15 #   endif
16 #endif
17 
18 using namespace samchon::example::console_chat_server;
19 
20 void main()
21 {
22     ChatServer chatServer;
23     chatServer\&.open();
24 
25     system("pause");
26 }

.fi
.PP
.RE
.PP
\fBAuthor:\fP
.RS 4
Jeongho Nam 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void open ()\fC [virtual]\fP"

.PP
Open the server\&. 
.PP
\fBNote:\fP
.RS 4
It holds (monopolies) a thread\&. 
.RE
.PP

.PP
Reimplemented in \fBIWebServer\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Samchon Framework for CPP from the source code\&.
