.TH "Datetime" 3 "Mon Oct 26 2015" "Version 1.0.0" "Samchon Framework for CPP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Datetime \- \fBDate\fP and time\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Datetime\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBDatetime\fP ()"
.br
.ti -1c
.RI "\fBDatetime\fP (const super::super &)"
.br
.RI "\fICopy Constructor\&. \fP"
.ti -1c
.RI "\fBDatetime\fP (super::super &&)"
.br
.ti -1c
.RI "\fBDatetime\fP (int year, int month, int date, int hour=0, int min=0, int sec=0)"
.br
.RI "\fIConstruct from datetime elements\&. \fP"
.ti -1c
.RI "\fBDatetime\fP (const \fBWeakString\fP &)"
.br
.RI "\fIConstruct from \fBWeakString\fP\&. \fP"
.ti -1c
.RI "\fBDatetime\fP (long long linuxTime)"
.br
.RI "\fIConstruct from linux_time\&. \fP"
.ti -1c
.RI "virtual void \fBset\fP (const \fBWeakString\fP &) override"
.br
.RI "\fISet by weak_string\&. \fP"
.ti -1c
.RI "void \fBset\fP (int year, int month, int date, int hours=0, int minutes=0, int seconds=0)"
.br
.ti -1c
.RI "void \fBset\fP (long long linuxTime)"
.br
.ti -1c
.RI "virtual void \fBsetYear\fP (int)"
.br
.RI "\fISet year of the \fBDate\fP\&. \fP"
.ti -1c
.RI "virtual void \fBsetMonth\fP (int)"
.br
.RI "\fISet month of the \fBDate\fP\&. \fP"
.ti -1c
.RI "virtual void \fBsetDate\fP (int)"
.br
.ti -1c
.RI "void \fBsetHour\fP (int)"
.br
.RI "\fISet hour\&. \fP"
.ti -1c
.RI "void \fBsetMinute\fP (int)"
.br
.RI "\fISet minute\&. \fP"
.ti -1c
.RI "void \fBsetSecond\fP (int)"
.br
.RI "\fISet hour\&. \fP"
.ti -1c
.RI "virtual void \fBaddYear\fP (int) override"
.br
.RI "\fIAdd years to the \fBDate\fP\&. \fP"
.ti -1c
.RI "virtual void \fBaddMonth\fP (int) override"
.br
.RI "\fIAdd months to the \fBDate\fP\&. \fP"
.ti -1c
.RI "virtual void \fBaddWeek\fP (int) override"
.br
.RI "\fIAdd weeks to the \fBDate\fP\&. \fP"
.ti -1c
.RI "virtual void \fBaddDate\fP (int) override"
.br
.RI "\fIAdd days to the \fBDate\fP\&. \fP"
.ti -1c
.RI "void \fBaddHour\fP (int)"
.br
.RI "\fIAdd hours\&. \fP"
.ti -1c
.RI "void \fBaddMinute\fP (int)"
.br
.RI "\fIAdd minutes\&. \fP"
.ti -1c
.RI "void \fBaddSecond\fP (int)"
.br
.RI "\fIAdd seconds\&. \fP"
.ti -1c
.RI "auto \fBgetHour\fP () const  \-> int"
.br
.RI "\fIGet hour\&. \fP"
.ti -1c
.RI "auto \fBgetMinute\fP () const  \-> int"
.br
.RI "\fIGet minute\&. \fP"
.ti -1c
.RI "auto \fBgetSecond\fP () const  \-> int"
.br
.RI "\fIGet second\&. \fP"
.ti -1c
.RI "virtual auto \fBtoString\fP () const  \-> std::string override"
.br
.RI "\fIConverts the \fBDatetime\fP to std::string\&. \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
\fBDate\fP and time\&. 

\fBDatetime\fP is a \fBDate\fP having hours, minutes and seconds addictionally\&. 
.PP
\fB[Inherited]\fP
.RS 4

.RE
.PP
\fBDate\fP class is a chrono::time_point<std::chrono::system_clock>\&. 
.PP
\fBDate\fP represents the date with year, month and day in month\&. The basic date (local time) is from your operating system\&. 
.PP
\fB[Inherited]\fP
.RS 4

.RE
.PP
A time_point object expresses a point in time relative to a clock's epoch\&. 
.PP
Internally, the object stores an object of a duration type, and uses the Clock type as a reference for its epoch\&. 
.PP
Referenced comments of std::chrono::time_point 
.PD 0

.IP "\(bu" 2
http://www.cplusplus.com/reference/chrono/time_point/
.PP
 
.PP
\fBSee also:\fP
.RS 4
\fBsamchon::library\fP 
.RE
.PP
\fBAuthor:\fP
.RS 4
Jeongho Nam 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBDatetime\fP ()"
Default Constructor
.PP
The datetime will be now (Now from operating system) 
.SS "\fBDatetime\fP (const super::super & date)"

.PP
Copy Constructor\&. Copy the date from another \fBDate\fP
.PP
\fBParameters:\fP
.RS 4
\fIdate\fP Target to be copied 
.RE
.PP

.SS "\fBDatetime\fP (super::super && date)"

.PP
Move Constructor
.PP
Gets the date from other and truncate the other
.PP
\fBParameters:\fP
.RS 4
\fIdate\fP Target to be moved 
.RE
.PP

.SS "\fBDatetime\fP (int year, int month, int date, int hour = \fC0\fP, int min = \fC0\fP, int sec = \fC0\fP)"

.PP
Construct from datetime elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fIyear\fP ex) 2015 
.br
\fImonth\fP January to December\&. 1 ~ 12 
.br
\fIdate\fP Day in month\&. 1 ~ 31 
.br
\fIhour\fP Hours (0-23) 
.br
\fImin\fP Minutes (0-59) 
.br
\fIsec\fP Seconds (0-59)
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIinvalid_argument\fP parameter is out of its own range\&. 
.RE
.PP

.SS "\fBDatetime\fP (const \fBWeakString\fP & wStr)"

.PP
Construct from \fBWeakString\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwstr\fP A weak_string expressing the date\&. (1991-01-01 09:27:03) 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIinvalid_argument\fP parameter is out of its own range\&. 
.RE
.PP

.SS "\fBDatetime\fP (long long linuxTime)"

.PP
Construct from linux_time\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlinuxTime\fP linux_time to be converted 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void set (const \fBWeakString\fP & wStr)\fC [override]\fP, \fC [virtual]\fP"

.PP
Set by weak_string\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwstr\fP A weak_string expressing the date\&. (1991-01-01 09:27:03) 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIinvalid_argument\fP parameter is out of its own range\&. 
.RE
.PP

.PP
Reimplemented from \fBDate\fP\&.
.SS "void set (int year, int month, int date, int hours = \fC0\fP, int minutes = \fC0\fP, int seconds = \fC0\fP)"

.PP
\fBExceptions:\fP
.RS 4
\fIinvalid_argument\fP parameter is out of range (ex: month -> 13) 
.RE
.PP

.SS "void set (long long linuxTime)"

.SS "void setYear (int val)\fC [virtual]\fP"

.PP
Set year of the \fBDate\fP\&. If previous date is leaf month's expiration date and target year what you want is not leaf, the date will be 28
.PP
.PD 0
.IP "\(bu" 2
2000-02-29 -> setYear(2001) -> 2001-02-28 
.IP "\(bu" 2
2001-02-28 -> setYear(2000) -> 2000-02-08
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Target year 
.RE
.PP

.PP
Reimplemented from \fBDate\fP\&.
.SS "void setMonth (int val)\fC [virtual]\fP"

.PP
Set month of the \fBDate\fP\&. If the expiration date of the month will be shrinked, the date will be changed to the expiration date
.PP
.PD 0
.IP "\(bu" 2
2000-03-31 -> setMonth(4) -> 2000-04-30 
.IP "\(bu" 2
2007-08-31 -> setMonth(9) -> 2007-09-30
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Target month (1 - 12) 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIinvalid_argument\fP month is out of range 
.RE
.PP

.PP
Reimplemented from \fBDate\fP\&.
.SS "void setDate (int val)\fC [virtual]\fP"

.PP
Set date of the \fBDate\fP
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Target day in month 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIinvalid_argument\fP When date is over expiration date in month 
.RE
.PP

.PP
Reimplemented from \fBDate\fP\&.
.SS "void setHour (int val)"

.PP
Set hour\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Target hour (0 - 23) 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIinvalid_argument\fP When hour is out of range 
.RE
.PP

.SS "void setMinute (int val)"

.PP
Set minute\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Target minute (0 - 59) 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIinvalid_argument\fP When minute is out of range 
.RE
.PP

.SS "void setSecond (int val)"

.PP
Set hour\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Target second (0 - 59) 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIinvalid_argument\fP When second is out of range 
.RE
.PP

.SS "void addYear (int val)\fC [override]\fP, \fC [virtual]\fP"

.PP
Add years to the \fBDate\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Years to add 
.RE
.PP

.PP
Reimplemented from \fBDate\fP\&.
.SS "void addMonth (int val)\fC [override]\fP, \fC [virtual]\fP"

.PP
Add months to the \fBDate\fP\&. Not a matter to val is over 12\&. If the month is over 12, then years will be added\&.
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Months to add 
.RE
.PP

.PP
Reimplemented from \fBDate\fP\&.
.SS "void addWeek (int val)\fC [override]\fP, \fC [virtual]\fP"

.PP
Add weeks to the \fBDate\fP\&. Not a matter that val is too huge\&. If the adding weeks derives modification in month or year, then it will be\&.
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Weeks to add 
.RE
.PP

.PP
Reimplemented from \fBDate\fP\&.
.SS "void addDate (int val)\fC [override]\fP, \fC [virtual]\fP"

.PP
Add days to the \fBDate\fP\&. Not a matter that val is too huge\&. If the adding dates derives modification in month or year, then it will be\&.
.PP
\fBParameters:\fP
.RS 4
\fIval\fP Days to add 
.RE
.PP

.PP
Reimplemented from \fBDate\fP\&.
.SS "void addHour (int val)"

.PP
Add hours\&. It's same with operator+=(chrono::hours(val)) 
.PP
Do not worry about the out of range of the hour(val) Parent items like date, month and years will be adjusted automatically\&. 
.PP
\fBParameters:\fP
.RS 4
\fIval\fP hours to add 
.RE
.PP

.SS "void addMinute (int val)"

.PP
Add minutes\&. 
.PP
\fBIt's same with operator+=(chrono::minutes(val))\fP
.RS 4

.RE
.PP
\fB\fP
.RS 4
Do not worry about the out of range of the minutes(val) Parent items like date, month and years will be adjusted automatically\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIval\fP minutes to add 
.RE
.PP

.SS "void addSecond (int val)"

.PP
Add seconds\&. 
.PP
\fBIt's same with operator+=(chrono::seconds(val))\fP
.RS 4

.RE
.PP
\fB\fP
.RS 4
Do not worry about the out of range of the seconds(val) Parent items like date, month and years will be adjusted automatically\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIval\fP seconds to add 
.RE
.PP

.SS "int getHour () const \-> int"

.PP
Get hour\&. 
.PP
\fBReturns:\fP
.RS 4
hour of the \fBDatetime\fP to integer 
.RE
.PP

.SS "int getMinute () const \-> int"

.PP
Get minute\&. 
.PP
\fBReturns:\fP
.RS 4
minute of the \fBDatetime\fP to integer 
.RE
.PP

.SS "int getSecond () const \-> int"

.PP
Get second\&. 
.PP
\fBReturns:\fP
.RS 4
second of the \fBDatetime\fP to integer 
.RE
.PP

.SS "auto toString () const \-> std::string\fC [override]\fP, \fC [virtual]\fP"

.PP
Converts the \fBDatetime\fP to std::string\&. 
.PP
\fBReturns:\fP
.RS 4
std::string expressing the \fBDatetime\fP 
.RE
.PP

.PP
Reimplemented from \fBDate\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Samchon Framework for CPP from the source code\&.
