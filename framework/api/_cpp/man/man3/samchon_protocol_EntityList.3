.TH "EntityList< _Ty >" 3 "Mon Oct 26 2015" "Version 1.0.0" "Samchon Framework for CPP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
EntityList< _Ty > \- An \fBEntity\fP and a static list containing \fBEntity\fP objects\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <EntityList\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBEntityList\fP ()"
.br
.RI "\fIDefault Constructor\&. \fP"
.ti -1c
.RI "virtual void \fBconstruct\fP (std::shared_ptr< \fBlibrary::XML\fP > xml) override"
.br
.RI "\fIConstruct data of the \fBEntity\fP from an XML object\&. \fP"
.ti -1c
.RI "virtual auto \fBtoXML\fP () const  \-> std::shared_ptr< \fBlibrary::XML\fP > override"
.br
.RI "\fIGet an XML object represents the \fBEntityList\fP\&. \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 

.SS "template<typename _Ty>class samchon::protocol::EntityList< _Ty >"
An \fBEntity\fP and a static list containing \fBEntity\fP objects\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Ty\fP A type of children \fBEntity\fP\&. Must be a class derived from an \fBEntity\fP\&.
.RE
.PP
.PP
\fBEntityList\fP is a static array containing children objects derived from an \fBEntity\fP class\&.
.PP
\fBEntityList\fP, its allocated memory space for each child is fixed and cannot contain derived a entity class from the child entity type\&. It has advantages on performance by direct accessment and static memory allocation for child, however, its increasement of performance is not eminent\&. 
.PP
.PD 0
.IP "\(bu" 2
EntityList<Animal> is specified 
.IP "\(bu" 2
Dog is extended from the Animal 
.IP "\(bu" 2
EntityList<Animal> cannot contain Dog\&. You can try insertion of the Dog class into the \fBEntityList\fP, but only memory size of Animal is allocated, so that derived member variables and methods are all truncated\&.
.PP
\fB[Inherited]\fP
.RS 4

.RE
.PP
\fBEntity\fP is a class for standardization of expression method using on network I/O by XML\&. If \fBInvoke\fP is a standard message protocol of Samchon Framework which must be kept, \fBEntity\fP is a recommended semi-protocol of message for expressing a data class\&. Following the semi-protocol \fBEntity\fP is not imposed but encouraged\&. 
.PP
As we could get advantages from standardization of message for network I/O with \fBInvoke\fP, we can get additional advantage from standardizing expression method of data class with \fBEntity\fP\&. We do not need to know a part of network communication\&. Thus, with the \fBEntity\fP, we can only concentrate on entity's own logics and relationships between another entities\&. \fBEntity\fP does not need to how network communications are being done\&. 
.PP
 
.PP
\fBExample source\fP
.RS 4

.PP
.nf
1 #include <iostream>
2 
3 #include <samchon/protocol/Entity\&.hpp>
4 #include <samchon/protocol/IHTMLEntity\&.hpp>
5 #include <samchon/protocol/SharedEntityArray\&.hpp>
6 
7 #include <samchon/library/XML\&.hpp>
8 
9 #ifdef _WIN64
10 #   ifdef _DEBUG
11 #       pragma comment(lib, "x64/Debug/SamchonFramework\&.lib")
12 #   else
13 #       pragma comment(lib, "x64/Release/SamchonFramework\&.lib")
14 #   endif
15 #else
16 #   ifdef _DEBUG
17 #       pragma comment(lib, "Debug/SamchonFramework\&.lib")
18 #   else
19 #       pragma comment(lib, "Release/SamchonFramework\&.lib")
20 #   endif
21 #endif
22 
23 using namespace std;
24 using namespace samchon::library;
25 using namespace samchon::protocol;
26 
27 class Member 
28     : public Entity, public virtual IHTMLEntity
29 {
30 protected:
31     typedef Entity super;
32 
33     string id;
34     string name;
35     int age;
36     int grade;
37 
38 public:
39     /* ---------------------------------------------------------------------
40         CONSTRUCTORS
41     --------------------------------------------------------------------- */
42     Member() 
43         : super(), IHTMLEntity()
44     {
45     };
46     Member(const string &id, const string &name, int age, int grade)
47         : super(), IHTMLEntity()
48     {
49         this->id = id;
50         this->name = name;
51         this->age = age;
52         this->grade = grade;
53     };
54     virtual ~Member() = default;
55 
56     virtual void construct(shared_ptr<XML> xml) override
57     {
58         this->id = xml->getProperty("id");
59         this->name = xml->getProperty("name");
60         this->age = xml->getProperty<int>("age");
61         this->grade = xml->getProperty<int>("grade");
62     };
63 
64     /* ---------------------------------------------------------------------
65         GETTERSs
66     --------------------------------------------------------------------- */
67     virtual auto key() const -> std::string override
68     {
69         return this->id;
70     };
71 
72     /* ---------------------------------------------------------------------
73         XML EXPORTERS
74     --------------------------------------------------------------------- */
75     virtual auto TAG() const -> string override
76     {
77         return "member";
78     };
79     virtual auto toXML() const -> shared_ptr<XML>
80     {
81         shared_ptr<XML> &xml = super::toXML();
82         xml->setProperty("id", id);
83         xml->setProperty("name", name);
84         xml->setProperty("age", age);
85         xml->setProperty("grade", grade);
86         
87         return move(xml);
88     };
89     virtual auto toHTML() const -> string
90     {
91         return toTR(id, name, age, grade);
92     };
93 };
94 
95 class MemberArray
96     : public SharedEntityArray<Member>,
97     public virtual IHTMLEntity
98 {
99 protected:
100     typedef SharedEntityArray<Member> super;
101 
102     string application;
103     int department;
104     Member *chief;
105 
106 public:
107     /* ---------------------------------------------------------------------
108         CONSTRUCTORS
109     --------------------------------------------------------------------- */
110     MemberArray()
111         : super(), IHTMLEntity()
112     {
113         this->chief = nullptr;
114     };
115     virtual ~MemberArray() = default;
116 
117     // You don't need to consider children(Member) objects
118     // Just concentrate on constructing MemberArray's own member variables
119     virtual void construct(shared_ptr<XML> xml) override
120     {
121         super::construct(xml);
122 
123         this->application = xml->getProperty("application");
124         this->department = xml->getProperty<int>("department");
125 
126         if(xml->hasProperty("chief") == true && this->has( xml->getProperty("chief") ) == true)
127             this->chief = this->get( xml->getProperty("cheif") )\&.get();
128     };
129 
130 protected:
131     //FACTORY METHOD FOR MEMBER
132     virtual auto createChild(shared_ptr<XML> = nullptr) -> Member* override
133     {
134         return new Member();
135     };
136 
137     /* ---------------------------------------------------------------------
138         XML EXPORTERS
139     --------------------------------------------------------------------- */
140 public:
141     virtual auto TAG() const -> string override
142     {
143         return "memberArray";
144     };
145     virtual auto CHILD_TAG() const -> string override
146     {
147         return "member";
148     };
149 
150     // You don't need to consider children(Member) objects
151     // Just concentrate on expressing MemberArray's own member variables
152     virtual auto toXML() const -> shared_ptr<XML>
153     {
154         shared_ptr<XML> &xml = super::toXML();
155         xml->setProperty("application", application);
156         xml->setProperty("department", department);
157         
158         if(chief != nullptr)
159             xml->setProperty("cheif", chief->key());
160 
161         return move(xml);
162     };
163     virtual auto toHTML() const -> string
164     {
165         string html = "<table>\n";
166         html += toTH("ID", "Name", "Age", "Grade") + "\n";
167 
168         for (size_t i = 0; i < 2; i++)
169             html += at(i)->toHTML() + "\n";
170 
171         html += "</table>";
172         return move(html);
173     };
174 };
175 
176 void main()
177 {
178     string str = string("") +
179         "<memberArray application='framework' department='7' cheif='samchon'>\n" +
180         "   <member id='samchon' name='Jeongho Nam' age='27' grade='5' />" +
181         "   <member id='submaster' name='No Name' age='100' grade='4' />" +
182         "   <member id='john' name='John Doe' age='33' grade='2' />" +
183         "   <member id='bad_man' name='Bad Man' age='44' grade='-1' />" +
184         "   <member id='guest' name='Guest' age='0' grade='0' />" +
185         "</memberArray>";
186     shared_ptr<XML> xml(new XML(str));
187 
188     MemberArray memberArray;
189     memberArray\&.construct(xml);
190 
191     memberArray\&.emplace_back(new Member("freshman", "A fresh man", 20, 2));
192     memberArray\&.emplace_back(new Member("senior", "A senior", 70, 2));
193 
194     cout << memberArray\&.toXML()->toString() << endl << endl;
195     cout << memberArray\&.toHTML() << endl;
196     system("pause");
197 }

.fi
.PP
.RE
.PP
.SS "Result of the example "
.PP
 
.PP
\fBNote:\fP
.RS 4
.RE
.PP
I say repeatedly\&. Expression method of \fBEntity\fP is recommended, but not imposed\&. It's a semi protocol for network I/O but not a essential protocol must be kept\&. The expression method of \fBEntity\fP, using on network I/O, is expressed by XML string\&. 
.PP
If your own network system has a critical performance issue on communication data class, it would be better to using binary communication (with \fBByteArray\fP or boost::serialization)\&. Don't worry about the problem! \fBInvoke\fP also provides methods for binary data (\fBByteArray\fP)\&. 
.PP
\fBSee also:\fP
.RS 4
\fBprotocol\fP 
.RE
.PP
\fBAuthor:\fP
.RS 4
Jeongho Nam
.RE
.PP
\fBWarning:\fP
.RS 4
.RE
.PP
If a data structure has recursive and hierarchical relationship, never use the \fBEntityList\fP\&. \fBEntityList\fP's memory allocation is static\&. The recursive relationship causes infinite memory allocation\&. It must generates stack overflow\&. 
.PP
Use \fBEntityGroup\fP instead\&. 
.PP
.PD 0
.IP "\(bu" 2
class NTCriteria : public EntityList<NTCriteria> causes a stack overflow\&. 
.IP "\(bu" 2
class NTCriteria : public SharedEntityList<NTCriteria> doesn't cause the stack overflow\&.
.PP
\fBWarning:\fP
.RS 4
.RE
.PP
Unlike \fBEntityArray\fP containing children serialized, \fBEntityList\fP's static memory allocation and accessment for a child, its advantage doesn't seemed to have eminent advantage on performance\&. As there's not meaningful advantage but has only disadvantage that cannot containing derived objects, I'm planning to depreciate the \fBEntityList\fP in next generation\&. 
.PP
Use SharedEntityList instead will be better I think\&. 
.SH "Member Function Documentation"
.PP 
.SS "virtual void construct (std::shared_ptr< \fBlibrary::XML\fP > xml)\fC [inline]\fP, \fC [override]\fP, \fC [virtual]\fP"

.PP
Construct data of the \fBEntity\fP from an XML object\&. Constructs the \fBEntityList\fP's own member variables only from the input XML object\&. 
.PP
Do not consider about constructing children \fBEntity\fP objects' data in \fBEntityList::construct()\fP\&. Those children \fBEntity\fP objects' data will constructed by their own \fBconstruct()\fP method\&. Even insertion of XML objects representing children are done by abstract method of \fBEntityList::toXML()\fP\&. 
.PP
Constructs only data of \fBEntityList\fP's own\&. 
.PP
\fB[Inherited]\fP
.RS 4
Construct data of the \fBEntity\fP from an XML object\&. 
.RE
.PP
Overrides the \fBconstruct()\fP method and fetch data of member variables from the XML\&. 
.PP
By recommended guidance, data representing member variables are contained in properties of the put XML object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIxml\fP An xml used to construct data of entity 
.RE
.PP

.PP
Implements \fBEntity\fP\&.
.SS "virtual auto toXML () const \-> std::shared_ptr<\fBlibrary::XML\fP>\fC [inline]\fP, \fC [override]\fP, \fC [virtual]\fP"

.PP
Get an XML object represents the \fBEntityList\fP\&. Archives the \fBEntityList\fP's own member variables only to the returned XML object\&. 
.PP
Do not consider about archiving children \fBEntity\fP objects' data in \fBEntityList::toXML()\fP\&. Those children \fBEntity\fP objects will converted to XML object by their own \fBtoXML()\fP method\&. The insertion of XML objects representing children are done by abstract method of \fBEntityList::toXML()\fP\&. 
.PP
Archives only data of \fBEntityList\fP's own\&. 
.PP
\fB[Inherited]\fP
.RS 4
Get an XML object represents the \fBEntity\fP\&. 
.RE
.PP
Returns an XML object that can represents the \fBEntity\fP containing member variables into properties\&. 
.PP
A member variable (not object, but atomic value like number, string or date) is categorized as a property within the framework of entity side\&. Thus, when overriding a \fBtoXML()\fP method and archiving member variables to an XML object to return, puts each variable to be a property belongs to only an XML object\&. 
.PP
Don't archive the member variable of atomic value to XML::value causing enormouse creation of XML objects to number of member variables\&. An \fBEntity\fP must be represented by only an XML instance (tag)\&. 
.PP
Standard Usage  Non-standard usage abusing value   <memberList>
.br
      <member id='jhnam88' name='Jeongho+Nam' birthdate='1988-03-11' />
.br
      <member id='master' name='Administartor' birthdate='2011-07-28' />
.br
 </memberList>  <member>
.br
      <id>jhnam88</id>
.br
      <name>Jeongho+Nam</name>
.br
      <birthdate>1988-03-11</birthdate>
.br
 </member>   
.PP
\fBReturns:\fP
.RS 4
An XML object representing the \fBEntity\fP\&. 
.RE
.PP

.PP
Reimplemented from \fBEntity\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Samchon Framework for CPP from the source code\&.
