.TH "GeneticAlgorithm< GeneArray, Compare >" 3 "Mon Oct 26 2015" "Version 1.0.0" "Samchon Framework for CPP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
GeneticAlgorithm< GeneArray, Compare > \- A genetic algorithm class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <GeneticAlgorithm\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBGeneticAlgorithm\fP (bool \fBunique\fP, double \fBmutationRate\fP=0\&.015, size_t \fBtournament\fP=10)"
.br
.RI "\fIConstruct from parameters of Genetic Algorithm\&. \fP"
.ti -1c
.RI "auto \fBevolveGeneArray\fP (std::shared_ptr< GeneArray > geneArray, size_t population, size_t generation) const  \-> std::shared_ptr< GeneArray >"
.br
.RI "\fIEvolve a GeneArray\&. \fP"
.ti -1c
.RI "auto \fBevolvePopulation\fP (std::shared_ptr< \fBMyPopulation\fP > population) const  \-> std::shared_ptr< \fBMyPopulation\fP >"
.br
.RI "\fIEvolve population, a mass of GeneArray(es) \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "auto \fBselection\fP (std::shared_ptr< \fBMyPopulation\fP > population) const  \-> std::shared_ptr< GeneArray >"
.br
.RI "\fISelect the best GeneArray in population from tournament\&. \fP"
.ti -1c
.RI "auto \fBcrossover\fP (std::shared_ptr< GeneArray > &parent1, std::shared_ptr< GeneArray > &parent2) const  \-> std::shared_ptr< GeneArray >"
.br
.RI "\fICreate a new GeneArray by crossing over two GeneArray(s) \fP"
.ti -1c
.RI "void \fBmutate\fP (std::shared_ptr< GeneArray > geneArray) const "
.br
.RI "\fICause a mutation on the GeneArray\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fBunique\fP"
.br
.RI "\fIWhether each element (Gene) is unique in their GeneArray\&. \fP"
.ti -1c
.RI "double \fBmutationRate\fP"
.br
.RI "\fIRate of mutate ocurrence\&. \fP"
.ti -1c
.RI "size_t \fBtournament\fP"
.br
.RI "\fISize of tournament in selection\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename GeneArray, typename Compare = std::less<GeneArray>>class samchon::library::GeneticAlgorithm< GeneArray, Compare >"
A genetic algorithm class\&. 

In the field of artificial intelligence, a genetic algorithm (GA) is a search heuristic that mimics the process of natural selection\&. This heuristic (also sometimes called a metaheuristic) is routinely used to generate useful solutions to optimization and search problems\&. 
.PP
Genetic algorithms belong to the larger class of evolutionary algorithms (EA), which generate solutions to optimization problems using techniques inspired by natural evolution, such as inheritance, mutation, selection, and crossover\&. 
.PP
.PD 0
.IP "\(bu" 2
Referenced Wikipedia: https://en.wikipedia.org/wiki/Genetic_algorithm
.PP
.PP
 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIGeneArray\fP An array(std::vector) containing genes as elments; sequnce listing\&.
.br

.br
 The GeneArray must be a type of \fIstd::vector\fP\&.
.br
\fICompare\fP A comparison class (or struct) returns whether left gene is more optimal\&.
.br

.br
 Default template parameter of Compare is \fIstd::less<GeneArray>\fP\&. It means to compare two std::vector (GeneArray must be a std::vector)\&. Thus, you've to keep follwing rules\&.
.br

.br
 If you don't want to follow the rules or want a custom comparison class, you have to realize a comparison class\&. The following code is an example realizing the comparison class\&. 
.PP
.nf
- GeneArray is inherited from <i>std::vector</i>
- GeneArray has custom <i>auto operator<(const GeneArray &) const -> bool</i>

.fi
.PP
.RE
.PP
.PP
.nf
template <typename _Ty>
struct MyCompare
{
auto operator()(const _Ty &newObj, const _Ty &prevObj) const -> bool;
};
.fi
.PP
.PP
.SS "Example source"
.PP
TSP - Traveling Salesman Problem 
.PP
\fBexamples/tsp/Scheduler\&.hpp\fP
.RS 4

.PP
.nf
1 #pragma once
2 #include <vector>
3 #include <memory>
4 
5 namespace samchon
6 {
7     namespace example
8     {
9         namespace tsp
10         {
11             class Travel;
12 
23             struct GAParameters
24             {
25                 double mutationRate;
26                 size_t tornament;
27 
28                 size_t population;
29                 size_t generation;
30             };
31 
38             class Scheduler
39             {
40             private:
44                 std::shared_ptr<Travel> travel;
45 
49                 struct GAParameters gaParameters;
50 
51             public:
55                 Scheduler(std::shared_ptr<Travel>, const struct GAParameters &);
56 
64                 auto optimize() -> std::shared_ptr<Travel>;
65             };
66         };
67     };
68 };

.fi
.PP
 
.RE
.PP
\fBexamples/tsp/Travel\&.hpp\fP
.RS 4

.PP
.nf
1 #pragma once
2 #include <vector>
3 #include <string>
4 
5 namespace samchon
6 {
7     namespace example
8     {
9         namespace tsp
10         {
11             class GeometryPoint;
12 
24             class Travel
25                 : public std::vector<GeometryPoint*>
26             {
27             private:
28                 typedef std::vector<GeometryPoint*> super;
29 
36                 double distance;
37 
38             public:
39                 /* -----------------------------------------------------------
40                     CONSTRUCTORS
41                 ----------------------------------------------------------- */
45                 Travel();
46 
55                 Travel(const Travel&);
56 
60                 Travel(Travel&&);
61     
62             private:
63                 /* -----------------------------------------------------------
64                     CALCULATORS
65                 ----------------------------------------------------------- */
69                 auto calcDistance() const -> double;
70 
71             public:
79                 auto operator<(const Travel &) const -> bool;
80 
81                 /* -----------------------------------------------------------
82                     EXPORTER
83                 ----------------------------------------------------------- */
96                 auto toString() const -> std::string;
97             };
98         };
99     };
100 };

.fi
.PP
 
.RE
.PP
\fBexamples/tsp/GeometryPoint\&.hpp\fP
.RS 4

.PP
.nf
1 #pragma once
2 #include <string>
3 
4 namespace samchon
5 {
6     namespace example
7     {
8         namespace tsp
9         {
19             class GeometryPoint
20             {
21             private:
25                 int uid;
26 
30                 double longitude;
31 
35                 double latitude;
36 
37             public:
38                 /* -----------------------------------------------------------
39                     CONSTRUCTORS
40                 ----------------------------------------------------------- */
47                 GeometryPoint(int);
48 
55                 GeometryPoint(int, double, double);
56 
57                 /* -----------------------------------------------------------
58                     CALCULATOR
59                 ----------------------------------------------------------- */
66                 auto calcDistance(const GeometryPoint &) const -> double;
67 
68                 /* -----------------------------------------------------------
69                     EXPORTER
70                 ----------------------------------------------------------- */
79                 auto toString() const -> std::string;
80             };
81         };
82     };
83 };

.fi
.PP
.RE
.PP
\fBexamples/tsp/main\&.cpp\fP
.RS 4

.PP
.nf
1 #include <iostream>
2 #include <Windows\&.h>
3 
4 #include "Scheduler\&.hpp"
5 #include "Travel\&.hpp"
6 #include "GeometryPoint\&.hpp"
7 
8 using namespace std;
9 using namespace samchon::example::tsp;
10 
11 #ifdef _WIN64
12 #   ifdef _DEBUG
13 #       pragma comment(lib, "x64/Debug/SamchonFramework\&.lib")
14 #   else
15 #       pragma comment(lib, "x64/Release/SamchonFramework\&.lib")
16 #   endif
17 #else
18 #   ifdef _DEBUG
19 #       pragma comment(lib, "Debug/SamchonFramework\&.lib")
20 #   else
21 #       pragma comment(lib, "Release/SamchonFramework\&.lib")
22 #   endif
23 #endif
24 
25 void toClipboard(const string &);
26 
27 void main()
28 {
29     //GEOMETRY COORPORATES
30     shared_ptr<Travel> travel(new Travel());
31     for(int i = 0; i < 20; i++)
32         travel->push_back(new GeometryPoint(i + 1));
33 
34     //OPTIMIZING
35     struct GAParameters gaParameters = {\&.03, 50, 100, 300};
36     
37     Scheduler scheduler(travel, gaParameters);
38     travel = scheduler\&.optimize();
39     
40     //PRINTING
41     string &str = travel->toString();
42     toClipboard(str);
43     cout << str << endl;
44     
45     system("pause");
46 }
47 
48 void toClipboard(const string &str)
49 {
50     OpenClipboard(0);
51     EmptyClipboard();
52     HGLOBAL hg = GlobalAlloc(GMEM_MOVEABLE, str\&.size());
53 
54     if (!hg)
55     {
56         CloseClipboard();
57         return;
58     }
59     memcpy(GlobalLock(hg), str\&.c_str(), str\&.size());
60 
61     GlobalUnlock(hg);
62     SetClipboardData(CF_TEXT, hg);
63     CloseClipboard();
64     GlobalFree(hg);
65 }

.fi
.PP
 
.RE
.PP
\fBexamples/tsp/Scheduler\&.cpp\fP
.RS 4

.PP
.nf
1 #include "Scheduler\&.hpp"
2 #   include "Travel\&.hpp"
3 
4 #include <samchon/library/GeneticAlgorithm\&.hpp>
5 
6 using namespace std;
7 using namespace samchon::library;
8 using namespace samchon::example::tsp;
9 
10 Scheduler::Scheduler(shared_ptr<Travel> travel, const GAParameters &gaParameteres)
11 {
12     this->travel = travel;
13     this->gaParameters = gaParameteres;
14 }
15 auto Scheduler::optimize() -> shared_ptr<Travel>
16 {
17     GeneticAlgorithm<Travel> geneticAlgorithm
18     (
19         true,
20         gaParameters\&.mutationRate,
21         gaParameters\&.tornament
22     );
23     
24     travel = 
25         geneticAlgorithm\&.evolveGeneArray
26         (
27             travel, 
28             gaParameters\&.population, 
29             gaParameters\&.generation
30         );
31     return travel;
32 }

.fi
.PP
 
.RE
.PP
\fBexamples/tsp/Travel\&.cpp\fP
.RS 4

.PP
.nf
1 #include "Travel\&.hpp"
2 #   include "GeometryPoint\&.hpp"
3 
4 #include <samchon/library/StringUtil\&.hpp>
5 
6 using namespace std;
7 using namespace samchon::library;
8 using namespace samchon::example::tsp;
9 
10 /* -----------------------------------------------------------
11     CONSTRUCTORS
12 ----------------------------------------------------------- */
13 Travel::Travel()
14     : super()
15 {
16     distance = INT_MIN;
17 }
18 Travel::Travel(const Travel &travel)
19     : super(travel)
20 {
21     distance = INT_MIN;
22 }
23 Travel::Travel(Travel &&travel)
24     : super(move(travel))
25 {
26     distance = travel\&.distance;
27 }
28 
29 /* -----------------------------------------------------------
30     CALCULATORS
31 ----------------------------------------------------------- */
32 auto Travel::calcDistance() const -> double
33 {
34     if(this->distance != INT_MIN)
35         return this->distance;
36 
37     double distance = 0\&.0;
38     for(size_t i = 1; i < size(); i++)
39         distance += at(i-1)->calcDistance(*at(i));
40 
41     ((Travel*)this)->distance = distance;
42     return distance;
43 }
44 auto Travel::operator<(const Travel &travel) const -> bool
45 {
46     return this->calcDistance() < travel\&.calcDistance();
47 }
48 
49 /* -----------------------------------------------------------
50     EXPORTER
51 ----------------------------------------------------------- */
52 auto Travel::toString() const -> string
53 {
54     string str =
55         "Distance: " + StringUtil::numberFormat(calcDistance()) + " km\n" + 
56         "uid    longitude   latitude\n";
57 
58     for(size_t i = 0; i < size(); i++)
59         str += at(i)->toString() + "\n";
60 
61     return move(str);
62 }

.fi
.PP
 
.RE
.PP
\fBexamples/tsp/GeometryPoint\&.cpp\fP
.RS 4

.PP
.nf
1 #include "GeometryPoint\&.hpp"
2 
3 #include <random>
4 #include <cmath>
5 #include <samchon/library/Math\&.hpp>
6 #include <samchon/library/StringUtil\&.hpp>
7 
8 using namespace std;
9 using namespace samchon::library;
10 using namespace samchon::example::tsp;
11 
12 /* -----------------------------------------------------------
13     CONSTRUCTORS
14 ----------------------------------------------------------- */
15 GeometryPoint::GeometryPoint(int uid)
16 {
17     this->uid = uid;
18     this->longitude = Math::random() * 180\&.0;
19     this->latitude = Math::random() * 180 - 90\&.0;
20 }
21 GeometryPoint::GeometryPoint(int uid, double longitude, double latitude)
22 {
23     this->uid = uid;
24     this->longitude = longitude;
25     this->latitude = latitude;
26 }
27 
28 /* -----------------------------------------------------------
29     CALCULATOR
30 ----------------------------------------------------------- */
31 auto GeometryPoint::calcDistance(const GeometryPoint &point) const -> double
32 {
33     if (longitude == point\&.longitude && latitude == point\&.latitude)
34         return 0\&.0;
35 
36     double latitude_radian1 = Math::degree_to_radian(this->latitude);
37     double latitude_radian2 = Math::degree_to_radian(point\&.latitude);
38     double theta = this->longitude - point\&.longitude;
39 
40     double val =
41         sin(latitude_radian1) * sin(latitude_radian2)
42         + cos(latitude_radian1) * cos(latitude_radian2) * cos(Math::degree_to_radian(theta));
43 
44     val = acos(val);
45     val = Math::radian_to_degree(val);
46     val = val * 60 * 1\&.1515;
47     val = val * 1\&.609344;
48 
49     return val;
50 }
51 
52 /* -----------------------------------------------------------
53     EXPORTER
54 ----------------------------------------------------------- */
55 auto GeometryPoint::toString() const -> string
56 {
57     return StringUtil::substitute
58         (
59             "{1}\t{2}\t{3}",
60             uid, longitude, latitude
61         );
62 }

.fi
.PP
.RE
.PP
.SS "Result of the example "
.PP
 
.PP
\fBWarning:\fP
.RS 4
.RE
.PP
Be careful for the mistakes of direction or position of Compare\&. 
.PP
Most of logical errors failed to access optimal solution are occured by those mistakens\&. 
.PP
\fBSee also:\fP
.RS 4
\fBlibrary::GAPopulation\fP 
.PP
\fBsamchon::library\fP 
.RE
.PP
\fBAuthor:\fP
.RS 4
Jeongho Nam 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBGeneticAlgorithm\fP (bool unique, double mutationRate = \fC0\&.015\fP, size_t tournament = \fC10\fP)\fC [inline]\fP"

.PP
Construct from parameters of Genetic Algorithm\&. 
.PP
\fBParameters:\fP
.RS 4
\fIunique\fP Whether each Gene is unique in their GeneArray 
.br
\fImutationRate\fP Rate of mutation 
.br
\fItournament\fP Size of tournament in selection 
.br
\fIelitism\fP Whether to keep the elitest GeneArray 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "auto evolveGeneArray (std::shared_ptr< GeneArray > geneArray, size_t population, size_t generation) const \-> std::shared_ptr<GeneArray>
			\fC [inline]\fP"

.PP
Evolve a GeneArray\&. Convinient method accessing to \fBevolvePopulation()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIgeneArray\fP An initial set of genes; sequence listing 
.br
\fIpopulation\fP Size of population in a generation 
.br
\fIgeneration\fP Size of generation in evolution
.RE
.PP
\fBReturns:\fP
.RS 4
A evolved GeneArray optimally 
.RE
.PP

.SS "auto evolvePopulation (std::shared_ptr< \fBMyPopulation\fP > population) const \-> std::shared_ptr<\fBMyPopulation\fP>
			\fC [inline]\fP"

.PP
Evolve population, a mass of GeneArray(es) 
.PP
\fBParameters:\fP
.RS 4
\fIpopulation\fP An initial population 
.RE
.PP

.SS "auto selection (std::shared_ptr< \fBMyPopulation\fP > population) const \-> std::shared_ptr<GeneArray>
			\fC [inline]\fP, \fC [private]\fP"

.PP
Select the best GeneArray in population from tournament\&. Selection is the stage of a genetic algorithm in which individual genomes are chosen from a population for later breeding (using crossover operator)\&. A generic selection procedure may be implemented as follows: 
.PP
.PD 0
.IP "1." 4
The fitness function is evaluated for each individual, providing fitness values, which are then normalized\&. Normalization means dividing the fitness value of each individual by the sum of all fitness values, so that the sum of all resulting fitness values equals 1\&.  
.IP "2." 4
The population is sorted by descending fitness values\&.  
.IP "3." 4
Accumulated normalized fitness values are computed (the accumulated fitness value of an individual is the sum of its own fitness value plus the fitness values of all the previous individuals)\&. The accumulated fitness of the last individual should be 1 (otherwise something went wrong in the normalization step)\&.  
.IP "4." 4
A random number R between 0 and 1 is chosen\&.  
.IP "5." 4
The selected individual is the first one whose accumulated normalized value is greater than R\&.  
.PP
.PP
.PD 0
.IP "\(bu" 2
Referenced Wekipedia: https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)
.PP
\fBParameters:\fP
.RS 4
\fIpopulation\fP The target of tournament 
.RE
.PP
\fBReturns:\fP
.RS 4
The best genes derived by the tournament 
.RE
.PP

.SS "auto crossover (std::shared_ptr< GeneArray > & parent1, std::shared_ptr< GeneArray > & parent2) const \-> std::shared_ptr<GeneArray>
			\fC [inline]\fP, \fC [private]\fP"

.PP
Create a new GeneArray by crossing over two GeneArray(s) crossover is a genetic operator used to vary the programming of a chromosome or chromosomes from one generation to the next\&. It is analogous to reproduction and biological crossover, upon which genetic algorithms are based\&. 
.PP
Cross over is a process of taking more than one parent solutions and producing a child solution from them\&. There are methods for selection of the chromosomes\&. 
.PP
.PD 0
.IP "\(bu" 2
Referenced Wikipedia: https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)
.PP
\fBParameters:\fP
.RS 4
\fIparent1\fP A parent sequence listing 
.br
\fIparent2\fP A parent sequence listing 
.RE
.PP

.SS "void mutate (std::shared_ptr< GeneArray > geneArray) const\fC [inline]\fP, \fC [private]\fP"

.PP
Cause a mutation on the GeneArray\&. Mutation is a genetic operator used to maintain genetic diversity from one generation of a population of genetic algorithm chromosomes to the next\&. It is analogous to biological mutation\&. 
.PP
Mutation alters one or more gene values in a chromosome from its initial state\&. In mutation, the solution may change entirely from the previous solution\&. Hence GA can come to better solution by using mutation\&. 
.PP
Mutation occurs during evolution according to a user-definable mutation probability\&. This probability should be set low\&. If it is set too high, the search will turn into a primitive random search\&. 
.PP
.PD 0
.IP "\(bu" 2
Referenced Wikipedia: https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)
.PP
\fBNote:\fP
.RS 4
.RE
.PP
Muttion is pursuing diversity\&. Mutation is useful for avoiding the following problem\&. 
.PP
When initial set of genes(GeneArray) is far away from optimail, without mutation (only with selection and crossover), the genetic algorithm has a tend to wandering outside of the optimal\&. 
.PP
Genes in the GeneArray will be swapped following percentage of the mutationRate\&. 
.PP
\fBParameters:\fP
.RS 4
\fIgeneArray\fP A container of genes to mutate 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBmutationRate\fP; 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "double mutationRate\fC [private]\fP"

.PP
Rate of mutate ocurrence\&. The mutationRate determines the percentage of occurence of mutation in a GeneArray\&.
.PP
\fBNote:\fP
.RS 4
.PD 0
.IP "\(bu" 2
When mutationRate is too high, it is hard to ancitipate studying on genetic algorithm\&. 
.IP "\(bu" 2
When mutationRate is too low and initial set of genes(GeneArray) is far away from optimal, the evolution tends to wandering outside of he optimal\&. 
.PP
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Samchon Framework for CPP from the source code\&.
