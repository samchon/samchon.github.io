.TH "EventDispatcher" 3 "Mon Oct 26 2015" "Version 1.0.0" "Samchon Framework for CPP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
EventDispatcher \- Abstract class for dispatching \fBEvent\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <EventDispatcher\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBEventDispatcher\fP ()"
.br
.RI "\fIDefault Constructor\&. \fP"
.ti -1c
.RI "\fBEventDispatcher\fP (const \fBEventDispatcher\fP &eventDispatcher)"
.br
.RI "\fICopy Constructor\&. \fP"
.ti -1c
.RI "\fBEventDispatcher\fP (\fBEventDispatcher\fP &&eventDispatcher)"
.br
.RI "\fIMove Constructor\&. \fP"
.ti -1c
.RI "void \fBaddEventListener\fP (int, void(*listener)(std::shared_ptr< \fBEvent\fP >))"
.br
.RI "\fIRegister an event listener\&. \fP"
.ti -1c
.RI "void \fBremoveEventListener\fP (int, void(*listener)(std::shared_ptr< \fBEvent\fP >))"
.br
.RI "\fIRemove a registered event listener\&. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "auto \fBdispatchEvent\fP (std::shared_ptr< \fBEvent\fP >) \-> bool"
.br
.RI "\fIDispatches an event to all listeners\&. \fP"
.ti -1c
.RI "auto \fBdispatchProgressEvent\fP (size_t x, size_t size) \-> bool"
.br
.RI "\fIConvenient method of dispatching a progress event\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::map< int, std::set< void(*)(std::shared_ptr< \fBEvent\fP >)> > \fBeventSetMap\fP"
.br
.RI "\fIA container storing listeners\&. \fP"
.ti -1c
.RI "\fBRWMutex\fP \fBmtx\fP"
.br
.RI "\fIA rw_mutex for concurrency\&. \fP"
.ti -1c
.RI "\fBSemaphore\fP \fBsemaphore\fP"
.br
.RI "\fIA semaphore for restricting thread size\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Abstract class for dispatching \fBEvent\fP\&. 

\fBEventDispatcher\fP is the base class for all classes that dispatch events\&. 
.PP
All the events are sent asynchronously\&. To avoid from creating tooo enourmouse threads dispatching events, all event sending processes will acuiqre a semaphore\&. The default permitted size of the semaphore is 2\&. 
.PP
.PD 0
.IP "\(bu" 2
Number of thread pools used to sending events is 2\&.
.PP
 
.PP
\fBExample source\fP
.RS 4

.PP
.nf
1 #include <iostream>
2 #include <thread>
3 #include <chrono>
4 
5 #include <samchon/library/EventDispatcher\&.hpp>
6 #include <samchon/library/Event\&.hpp>
7 #include <samchon/library/ProgressEvent\&.hpp>
8 
9 #ifdef _WIN64
10 #   ifdef _DEBUG
11 #       pragma comment(lib, "x64/Debug/SamchonFramework\&.lib")
12 #   else
13 #       pragma comment(lib, "x64/Release/SamchonFramework\&.lib")
14 #   endif
15 #else
16 #   ifdef _DEBUG
17 #       pragma comment(lib, "Debug/SamchonFramework\&.lib")
18 #   else
19 #       pragma comment(lib, "Release/SamchonFramework\&.lib")
20 #   endif
21 #endif
22 
23 using namespace std;
24 using namespace samchon::library;
25 
26 class Process
27     : public EventDispatcher
28 {
29 public:
30     Process()
31     {
32 
33     };
34 
35     void run()
36     {
37         dispatchEvent(shared_ptr<Event>(new Event(this, Event::ACTIVATE)));
38 
39         for (size_t i = 0; i < 100; i++)
40         {
41             this_thread::sleep_for(chrono::seconds(1));
42             dispatchEvent(shared_ptr<Event>(new ProgressEvent(this, i + 1, 100)));
43         }
44 
45         dispatchEvent(shared_ptr<Event>(new Event(this, Event::COMPLETE)));
46     };
47 };
48 
49 void handleActivate(shared_ptr<Event> event)
50 {
51     cout << "Activated" << endl;
52 }
53 void handleComplete(shared_ptr<Event> event)
54 {
55     cout << "Completed" << endl;
56 }
57 void handleProgress(shared_ptr<Event> event)
58 {
59     cout << dynamic_pointer_cast<ProgressEvent>(event)->getPercent() * 100\&.0 << "%" << endl;
60 }
61 
62 void main()
63 {
64     Process process;
65 
66     process\&.addEventListener(Event::ACTIVATE, handleActivate);
67     process\&.addEventListener(Event::COMPLETE, handleComplete);
68     process\&.addEventListener(ProgressEvent::PROGRESS, handleProgress);
69 
70     process\&.run();
71     system("pause");
72 }

.fi
.PP
.RE
.PP
\fBNote:\fP
.RS 4
.RE
.PP
\fBEventDispatcher\fP is a candidate to be depreciated\&. 
.PP
Since C++11, calling member method of a class by a new thread passing by static method and using void pointer are recommeded to avoid\&. As the reason, using \fIstd::thread\fP and \fIstd::bind\fP will be better\&. 
.PP
.PD 0
.IP "\(bu" 2
std::thread: http://www.cplusplus.com/reference/thread/thread/ 
.IP "\(bu" 2
std::bind: http://www.cplusplus.com/reference/functional/bind/
.PP
\fBSee also:\fP
.RS 4
\fBsamchon::library\fP 
.RE
.PP
\fBAuthor:\fP
.RS 4
Jeongho Nam 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBEventDispatcher\fP (const \fBEventDispatcher\fP & eventDispatcher)"

.PP
Copy Constructor\&. Copying an \fBEventDispatcher\fP instance does not copy the event listeners attached to it\&. (If your newly created node needs an event listener, you must attach the listener after creating the node\&.)
.PP
\fBParameters:\fP
.RS 4
\fIeventDispatcher\fP The object to copy 
.RE
.PP

.SS "\fBEventDispatcher\fP (\fBEventDispatcher\fP && eventDispatcher)"

.PP
Move Constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIeventDispatcher\fP The object to move 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void addEventListener (int type, void(*)(std::shared_ptr< \fBEvent\fP >) listener)"

.PP
Register an event listener\&. Registers an event listener object with an \fBEventDispatcher\fP object so that the listener receives notification of an event\&.
.PP
\fBWarning:\fP
.RS 4
Copying an \fBEventDispatcher\fP instance does not copy the event listeners attached to it\&. (If your newly created node needs an event listener, you must attach the listener after creating the node\&.) However, if you move an \fBEventDispatcher\fP instance, the event listeners attached to it move along with it\&.
.PP
If you no longer need an event listener, remove it by calling removeEventListener, or \fBEventDispatcher\fP already try to send events to the no longer needed listener and it can cause some confliction\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fItype\fP The type of event\&. 
.br
\fIlistener\fP The listener function processes the event\&. 
.RE
.PP

.SS "void removeEventListener (int type, void(*)(std::shared_ptr< \fBEvent\fP >) listener)"

.PP
Remove a registered event listener\&. Removes a listener from the \fBEventDispatcher\fP object\&. If there is no matching listener registered with the \fBEventDispatcher\fP object, a call to this method has no effect
.PP
\fBParameters:\fP
.RS 4
\fItype\fP The type of event\&. 
.br
\fIlistener\fP The listener function to remove\&. 
.RE
.PP

.SS "auto dispatchEvent (std::shared_ptr< \fBEvent\fP >) \-> bool\fC [protected]\fP"

.PP
Dispatches an event to all listeners\&. Dispatches an event into the event flow in the background\&. The \fBEvent::source\fP is the \fBEventDispatcher\fP object upon which the dispatchEvent\&. 
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP The \fBEvent\fP object that is dispatched into the event flow\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether there's some listener to listen the event 
.RE
.PP

.SS "auto dispatchProgressEvent (size_t x, size_t size) \-> bool\fC [protected]\fP"

.PP
Convenient method of dispatching a progress event\&. Dispatches a progress event into the event flow in the background The \fBEvent::source\fP is the \fBEventDispatcher\fP object upon with the dispatchProgressEvent
.PP
\fBParameters:\fP
.RS 4
\fIx\fP The number of current progress 
.br
\fIsize\fP The number of total progress 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether there's some listener to listen the progress event
.RE
.PP
\fBSee also:\fP
.RS 4
\fBProgressEvent\fP 
.PP
\fBEventDispatcher::dispatchEvent\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Samchon Framework for CPP from the source code\&.
